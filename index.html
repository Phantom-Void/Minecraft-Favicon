<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Minecraft in a favicon!</title>
<link id="favicon" rel="icon" href="">
<style>
  :root{--bg:#071018;--muted:#9fb7c9}
  html,body{height:100%;margin:0;background:var(--bg);color:#e6f3fb;font-family:Inter,Arial,Helvetica,sans-serif}
  .wrap{display:flex;flex-direction:column;align-items:center;padding:12px}
  h1{margin:6px 0 10px 0}
  canvas#view{width:640px;height:426px;border:4px solid #0f2130;
    image-rendering: pixelated; background:#000; display:block}
  .hint{color:var(--muted);margin-top:8px;font-size:13px;text-align:center}
</style>
</head>
<body>
<div class="wrap">
  <h1>PhantomVoid (aka Kindly_Band3322) Presents: Minecraft in a Favicon.</h1>
  <canvas id="view" width="240" height="160"></canvas>
  <div class="hint">WASD move â€¢ Mouse look (click box) â€¢ Space jump â€¢ LMB mine â€¢ I = inv â€¢ H = health (I and H will show in title)</div>
</div>

<script>
/* ------------------ CONFIG ------------------ */
const W=64,D=64,H=64;
const CANVAS_W=240, CANVAS_H=160;
const FOV=Math.PI/3;
const REACH=6;
const FAV=16;
const MAX_RENDER_DIST=48;

const AIR=0, STONE=1, DIRT=2, GRASS=3, LOG=4, LEAF=5;

/* ------------------ STORAGE ------------------ */
const blocks=new Uint8Array(W*H*D);
function idx(x,y,z){return ((y*D)+z)*W + x;}
function inBounds(x,y,z){return x>=0&&y>=0&&z>=0&&x<W&&y<H&&z<D;}
function getBlock(x,y,z){return inBounds(x,y,z)?blocks[idx(x,y,z)]:AIR;}
function setBlock(x,y,z,v){if(inBounds(x,y,z)) blocks[idx(x,y,z)] = v;}

/* ------------------ WORLD GEN (unchanged) ------------------ */
function pseudo(i){ i=(i<<13)^i; return 1-((i*(i*i*15731+789221)+1376312589)&0x7fffffff)/1073741824; }
function smooth2(x,y){
  const xi=Math.floor(x), yi=Math.floor(y);
  const xf=x-xi, yf=y-yi;
  const v00=pseudo(xi+yi*57), v10=pseudo(xi+1+yi*57);
  const v01=pseudo(xi+(yi+1)*57), v11=pseudo(xi+1+(yi+1)*57);
  const u=xf*xf*(3-2*xf), v=yf*yf*(3-2*yf);
  const a=v00*(1-u)+v10*u, b=v01*(1-u)+v11*u;
  return a*(1-v)+b*v;
}
function fractal2(x,y,oct=4,scale=1){
  let amp=1,freq=1,sum=0,norm=0;
  for(let i=0;i<oct;i++){
    sum+=smooth2(x*freq/scale,y*freq/scale)*amp;
    norm+=amp;
    amp*=0.5; freq*=2;
  }
  return sum/norm;
}
function fractal3(x,y,z){
  return (fractal2(x,y,3,24)+fractal2(y,z,3,24)+fractal2(x,z,3,24))/3;
}

function genWorld(){
  blocks.fill(AIR);
  for(let z=0;z<D;z++){
    for(let x=0;x<W;x++){
      let n=fractal2(x*0.6,z*0.6,5,32)*6 + fractal2(x*0.08,z*0.08,3,1)*10;
      const cb=(1-Math.hypot(x/W-0.5,z/D-0.5)/0.7071)*3.5;
      n+=cb;
      let h=Math.floor(H/4+n);
      h=Math.max(2,Math.min(H-6,h));
      for(let y=0;y<=h;y++){
        if(y<h-3) setBlock(x,y,z,STONE);
        else if(y<h-1) setBlock(x,y,z,DIRT);
        else setBlock(x,y,z,GRASS);
      }
    }
  }

  for(let z=2;z<D-2;z++)for(let x=2;x<W-2;x++)for(let y=2;y<H-6;y++){
    const n=fractal3(x*.12,y*.12,z*.12);
    const t=0.22+(y/H)*0.4;
    if(n>t) setBlock(x,y,z,AIR);
  }

  for(let z=2;z<D-2;z++)for(let x=2;x<W-2;x++){
    if(Math.random()<0.007){
      for(let y=H-2;y>1;y--){
        if(getBlock(x,y,z)===GRASS){
          const h=3+Math.floor(Math.random()*2);
          let ok=true;
          for(let yy=y+1;yy<=y+h+2;yy++)
            for(let lx=-2;lx<=2;lx++)
              for(let lz=-2;lz<=2;lz++)
                if(getBlock(x+lx,yy,z+lz)!==AIR) ok=false;
          if(!ok) break;

          for(let t=1;t<=h;t++) setBlock(x,y+t,z,LOG);
          for(let lx=-2;lx<=2;lx++)
            for(let lz=-2;lz<=2;lz++)
              for(let ly=h-1;ly<=h+1;ly++){
                const ax=x+lx, ay=y+ly+1, az=z+lz;
                if(Math.abs(lx)+Math.abs(lz)+Math.abs(ly)<=4 && getBlock(ax,ay,az)===AIR)
                  setBlock(ax,ay,az,LEAF);
              }
          break;
        }
      }
    }
  }
}
genWorld();


let px=4.5, py=20, pz=4.5;

(function findSpawn(){
  outer: for(let z=2;z<D-2;z++)
    for(let x=2;x<W-2;x++)
      for(let y=H-8;y>=4;y--){
        if(getBlock(x,y,z)!==AIR) continue;
        if(getBlock(x,y+1,z)!==AIR) continue;
        if(getBlock(x,y-1,z)===AIR) continue;
        if(getBlock(x,y-2,z)===AIR) continue;
        if(getBlock(x,y-3,z)===AIR) continue;
        px=x+.5; py=y+0.01; pz=z+.5;
        break outer;
      }
})();
let yaw=0, pitch=0;
let vy=0;
let grounded=false;
const PR=0.25, PH=1.6;
const canvas=document.getElementById('view'), ctx=canvas.getContext('2d');
const fav=document.createElement('canvas');
fav.width=FAV; fav.height=FAV;
const fctx=fav.getContext('2d');


const keys={};
let showInv=false, showHealth=false;
let health=20;
const inventory={};

window.addEventListener('keydown',e=>{
  keys[e.key]=true;
  if(e.key==='i'||e.key==='I'){ showInv=!showInv; updateTitle(); }
  if(e.key==='h'||e.key==='H'){ showHealth=!showHealth; updateTitle(); }
});
window.addEventListener('keyup',e=> keys[e.key]=false);

canvas.addEventListener('click',()=>canvas.requestPointerLock());

/* ------------ imVERTED MOUSE LOOK () ------------- */
window.addEventListener('mousemove', e=>{
  if(document.pointerLockElement!==canvas) return;

  yaw   += e.movementX * 0.0024;  // inverted horizontal
  pitch += e.movementY * 0.0024;  // inverted vertical

  const P = Math.PI/2 - 0.001;
  if(pitch>P) pitch=P;
  if(pitch<-P) pitch=-P;
});

/* ------------------ TITLE/INV ------------------ */
function addToInv(id){ inventory[id]=(inventory[id]||0)+1; updateTitle(); }
function blockName(id){
  switch(id){
    case STONE:return"stone"; case DIRT:return"dirt";
    case GRASS:return"grass"; case LOG:return"wood";
    case LEAF:return"leaf"; default:return"air";
  }
}
function updateTitle(){
  const p=Object.keys(inventory).map(k=>`${blockName(Number(k))} x${inventory[k]}`).join(', ');
  const parts=[];
  if(showInv) parts.push("Inv: "+(p||"empty"));
  if(showHealth) parts.push("Health: "+health);
  document.title = parts.length?parts.join(" | "):"Voxel â€” Fixed Camera (Fast)";
}

/* ------------------ COLLISION ------------------ */
function collidesAt(x,y,z){
  const minX=Math.floor(x-PR), maxX=Math.floor(x+PR);
  const minZ=Math.floor(z-PR), maxZ=Math.floor(z+PR);
  const minY=Math.floor(y+0.001), maxY=Math.floor(y+PH-0.001);
  for(let bx=minX;bx<=maxX;bx++)
    for(let bz=minZ;bz<=maxZ;bz++)
      for(let by=minY;by<=maxY;by++)
        if(getBlock(bx,by,bz)!==AIR) return true;
  return false;
}

/* ------------------ MOVEMENT ------------------ */
function movementStep(dt){
  const speed = keys['Shift']?0.16:0.09;
  let dx=0,dz=0;

  if(keys['w']||keys['W']){ dx+=Math.cos(yaw)*speed; dz+=Math.sin(yaw)*speed; }
  if(keys['s']||keys['S']){ dx-=Math.cos(yaw)*speed; dz-=Math.sin(yaw)*speed; }
  if(keys['a']||keys['A']){ dx+=Math.sin(yaw)*speed; dz-=Math.cos(yaw)*speed; }
  if(keys['d']||keys['D']){ dx-=Math.sin(yaw)*speed; dz+=Math.cos(yaw)*speed; }

  const nx=px+dx; if(!collidesAt(nx,py,pz)) px=nx;
  const nz=pz+dz; if(!collidesAt(px,py,nz)) pz=nz;

  const GRAV=-9.8;
  vy+=GRAV*dt;
  const newY=py+vy*dt;

  if(vy<=0){
    if(!collidesAt(px,newY,pz)){ py=newY; grounded=false; }
    else { py=Math.floor(newY)+1; vy=0; grounded=true; }
  }else{
    if(collidesAt(px,newY+PH-0.001,pz)) vy=0;
    else { py=newY; grounded=false; }
  }

  if((keys[' ']||keys['Space'])&&grounded){ vy=5.2; grounded=false; }
}

/* ------------------ UTILS ------------------ */
function dot(a,b){return a.x*b.x+a.y*b.y+a.z*b.z;}
function normalize(v){ const L=Math.hypot(v.x,v.y,v.z)||1; return {x:v.x/L,y:v.y/L,z:v.z/L}; }
function cross(a,b){ return {
  x:a.y*b.z-a.z*b.y,
  y:a.z*b.x-a.x*b.z,
  z:a.x*b.y-a.y*b.x
}; }

/* ------------------ CAMERA RAY DIR (world flipped) ------------------ */
function cameraRayDir(px2, py2, canvasW=CANVAS_W, canvasH=CANVAS_H){
  const nx=(px2-canvasW/2)/(canvasW/2);
  const ny=(canvasH/2-py2)/(canvasH/2);

  const aspect=canvasW/canvasH;
  const sx=Math.tan(FOV/2)*nx*aspect;
  const sy=Math.tan(FOV/2)*ny;

  const P = Math.PI/2 - 0.001;
  const p = Math.max(-P, Math.min(P, pitch));
  const y = yaw;

  const forward={
    x:Math.cos(p)*Math.cos(y),
    y:Math.sin(p),
    z:Math.cos(p)*Math.sin(y)
  };

  const right={
    x:Math.cos(y+Math.PI/2),
    y:0,
    z:Math.sin(y+Math.PI/2)
  };

  const up=cross(forward,right);

  let dir={
    x:forward.x + right.x*sx + up.x*sy,
    y:forward.y + right.y*sx + up.y*sy,
    z:forward.z + right.z*sx + up.z*sy
  };

  const L=Math.hypot(dir.x,dir.y,dir.z)||1;
  dir.x/=L;
  dir.y/=-L;   // ðŸ”¥ world flipped upright :-:
  dir.z/=L;

  return dir;
}

/* ------------------ DDA CAST ------------------ */
function castRay(origin,dir,maxDist=MAX_RENDER_DIST){
  let ox=origin.x, oy=origin.y, oz=origin.z;
  let vx=Math.floor(ox), vyv=Math.floor(oy), vz=Math.floor(oz);

  const stepX=dir.x>0?1:-1;
  const stepY=dir.y>0?1:-1;
  const stepZ=dir.z>0?1:-1;

  const tDeltaX=dir.x===0?Infinity:Math.abs(1/dir.x);
  const tDeltaY=dir.y===0?Infinity:Math.abs(1/dir.y);
  const tDeltaZ=dir.z===0?Infinity:Math.abs(1/dir.z);

  let tMaxX=dir.x===0?Infinity:((stepX>0?vx+1-ox:ox-vx)/Math.abs(dir.x));
  let tMaxY=dir.y===0?Infinity:((stepY>0?vyv+1-oy:oy-vyv)/Math.abs(dir.y));
  let tMaxZ=dir.z===0?Infinity:((stepZ>0?vz+1-oz:oz-vz)/Math.abs(dir.z));

  let t=0;
  const maxT=maxDist/Math.max(1e-6,Math.hypot(dir.x,dir.y,dir.z));

  if(getBlock(vx,vyv,vz)!==AIR)
    return {x:vx,y:vyv,z:vz,block:getBlock(vx,vyv,vz),dist:0,normal:{x:0,y:0,z:0}};

  let last=null;

  while(t<=maxT){
    if(vx<0||vyv<0||vz<0||vx>=W||vyv>=H||vz>=D) break;
    const b=getBlock(vx,vyv,vz);
    if(b!==AIR){
      let n={x:0,y:0,z:0};
      if(last){
        if(last.axis==='x') n.x=-last.sign;
        if(last.axis==='y') n.y=-last.sign;
        if(last.axis==='z') n.z=-last.sign;
      }
      return {x:vx,y:vyv,z:vz,block:b,dist:t,normal:n};
    }

    if(tMaxX<=tMaxY && tMaxX<=tMaxZ){
      vx+=stepX; t=tMaxX; tMaxX+=tDeltaX; last={axis:'x',sign:stepX};
    } else if(tMaxY<=tMaxX && tMaxY<=tMaxZ){
      vyv+=stepY; t=tMaxY; tMaxY+=tDeltaY; last={axis:'y',sign:stepY};
    } else{
      vz+=stepZ; t=tMaxZ; tMaxZ+=tDeltaZ; last={axis:'z',sign:stepZ};
    }
  }

  return null;
}

/* ------------------ RENDER ------------------ */
const canvasImg=ctx.createImageData(CANVAS_W,CANVAS_H);

function baseColor(id){
  switch(id){
    case STONE:return[141,141,141];
    case DIRT:return[155,106,60];
    case GRASS:return[77,182,59];
    case LOG:return[107,63,36];
    case LEAF:return[47,160,74];
    default:return[0,0,0];
  }
}

function renderFrame(){
  const buf=canvasImg.data;
  const eye={x:px,y:py+0.5,z:pz};
  const lightDir=normalize({x:0.7,y:0.6,z:0.3});

  for(let j=0;j<CANVAS_H;j++){
    for(let i=0;i<CANVAS_W;i++){
      const dir=cameraRayDir(i+0.5,j+0.5);
      const hit=castRay(eye,dir,MAX_RENDER_DIST);
      const o=(j*CANVAS_W+i)*4;

      if(hit){
        const col=baseColor(hit.block);
        let nl=0.5;
        if(hit.normal){
          const nn=normalize(hit.normal);
          nl+=Math.max(0,dot(nn,lightDir))*0.8;
        }
        const shade=Math.max(0.22,nl*(1-hit.dist/(MAX_RENDER_DIST*0.9)));
        buf[o]=col[0]*shade;
        buf[o+1]=col[1]*shade;
        buf[o+2]=col[2]*shade;
        buf[o+3]=255;
      } else {
        const t=1-(j/CANVAS_H);
        buf[o]=20+140*t;
        buf[o+1]=30+120*t;
        buf[o+2]=40+90*t;
        buf[o+3]=255;
      }
    }
  }

  ctx.putImageData(canvasImg,0,0);

  ctx.fillStyle='rgba(0,0,0,0.45)';
  ctx.fillRect(6,6,200,34);

  ctx.fillStyle='#fff';
  ctx.font='10px monospace';
  ctx.fillText(`Health: ${health}`,12,18);

  const invParts=Object.keys(inventory)
    .map(k=>`${blockName(Number(k))}:${inventory[k]}`)
    .slice(0,6)
    .join(' ');
  ctx.fillText(`Inv: ${invParts||"empty"}`,12,34);

  ctx.strokeStyle='rgba(255,255,255,0.7)';
  ctx.beginPath();
  ctx.moveTo(CANVAS_W/2-6,CANVAS_H/2);
  ctx.lineTo(CANVAS_W/2+6,CANVAS_H/2);
  ctx.moveTo(CANVAS_W/2,CANVAS_H/2-6);
  ctx.lineTo(CANVAS_W/2,CANVAS_H/2+6);
  ctx.stroke();

  fctx.imageSmoothingEnabled=false;
  fctx.clearRect(0,0,FAV,FAV);
  fctx.drawImage(canvas,0,0,FAV,FAV);
  document.getElementById('favicon').href=fav.toDataURL("image/png");
}

/* ------------------ MINING ------------------ */
function mineCenter(){
  const eye={x:px,y:py+0.5,z:pz};
  const dir=cameraRayDir(CANVAS_W/2,CANVAS_H/2);
  const hit=castRay(eye,dir,REACH);
  if(!hit) return;
  const id=getBlock(hit.x,hit.y,hit.z);
  if(id===AIR) return;
  addToInv(id);
  setBlock(hit.x,hit.y,hit.z,AIR);
}
window.addEventListener('mousedown',e=>{
  if(e.button===0) mineCenter();
});

/* ------------------ MAIN LOOP ------------------ */
let last=performance.now();
function loop(){
  const now=performance.now();
  const dt=Math.min(0.05,(now-last)/1000);
  last=now;

  movementStep(dt);
  renderFrame();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

</script>
</body>
</html>
