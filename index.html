// Build camera basis (Minecraft style, no roll)
const forward = normalize({
    x: Math.cos(pitch) * Math.cos(yaw),
    y: Math.sin(pitch),
    z: Math.cos(pitch) * Math.sin(yaw)
});

// Right = forward × worldUp
let right = cross(worldUp, forward);
right = normalize(right);

// True up = right × forward
let camUp = cross(right, forward);

// Camera projection plane
const fov = Math.tan((70 * Math.PI/180) / 2);

// Render
for (let y = 0; y < canvas.height; y++) {
    for (let x = 0; x < canvas.width; x++) {

        // Convert pixel to camera space
        let px = ( (x / canvas.width) * 2 - 1 ) * fov;
        let py = ( (y / canvas.height) * 2 - 1 ) * fov;

        // Build ray direction
        let dir = normalize({
            x: forward.x + right.x * px + camUp.x * py,
            y: forward.y + right.y * px + camUp.y * py,
            z: forward.z + right.z * px + camUp.z * py
        });

        // Raymarch
        let sx = camX;
        let sy = camY;
        let sz = camZ;

        for (let t = 0; t < 40; t++) {
            sx += dir.x * 0.5;
            sy += dir.y * 0.5;
            sz += dir.z * 0.5;

            const bx = Math.floor(sx);
            const by = Math.floor(sy);
            const bz = Math.floor(sz);

            if (get(bx, by, bz)) {
                ctx.fillStyle = `rgb(${50+by*10},${120+by*5},${50})`;
                ctx.fillRect(x, y, 1, 1);
                break;
            }
        }
    }
}
