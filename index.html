<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Voxel — Fixed</title>
<link id="favicon" rel="icon" href="">
<style>
  :root{--bg:#071018;--muted:#9fb7c9}
  html,body{height:100%;margin:0;background:var(--bg);color:#e6f3fb;font-family:Inter,Arial,Helvetica,sans-serif}
  .wrap{display:flex;flex-direction:column;align-items:center;padding:12px}
  h1{margin:6px 0 10px 0}
  canvas#view{width:640px;height:426px;border:4px solid #0f2130; image-rendering: pixelated; background:#000; display:block}
  .hint{color:var(--muted);margin-top:8px;font-size:13px;text-align:center}
</style>
</head>
<body>
  <div class="wrap">
    <h1>Voxel — Fixed Camera & Collision</h1>
    <canvas id="view" width="240" height="160"></canvas>
    <div class="hint">WASD move • Mouse look (click canvas) • Space jump • LMB mine • I = inv title • H = health title</div>
  </div>

<script>
/* Fixed Voxel Engine (no WebGL) */

/* CONFIG */
const W = 64, D = 64, H = 64;
const CANVAS_W = 240, CANVAS_H = 160;
const FOV = Math.PI/3;
const REACH = 6;
const FAV = 16;

/* blocks */
const AIR=0, STONE=1, DIRT=2, GRASS=3, LOG=4, LEAF=5;

/* storage */
const blocks = new Uint8Array(W*H*D);
function idx(x,y,z){return ((y*D)+z)*W + x;}
function inBounds(x,y,z){return x>=0&&y>=0&&z>=0&&x<W&&y<H&&z<D;}
function getBlock(x,y,z){ if(!inBounds(x,y,z)) return AIR; return blocks[idx(x,y,z)]; }
function setBlock(x,y,z,v){ if(!inBounds(x,y,z)) return; blocks[idx(x,y,z)]=v; }

/* noise + world gen omitted for brevity—unchanged */
function pseudo(i){ i=(i<<13)^i; return 1.0 - ((i*(i*i*15731+789221)+1376312589)&0x7fffffff)/1073741824.0; }
function smooth2(x,y){
  const xi=Math.floor(x), yi=Math.floor(y), xf=x-xi, yf=y-yi;
  const v00=pseudo(xi+yi*57), v10=pseudo(xi+1+yi*57), v01=pseudo(xi+(yi+1)*57), v11=pseudo(xi+1+(yi+1)*57);
  const u=xf*xf*(3-2*xf), v=yf*yf*(3-2*yf);
  const a=v00*(1-u)+v10*u, b=v01*(1-u)+v11*u;
  return a*(1-v)+b*v;
}
function fractal2(x,y,oct=4,scale=1){ let amp=1,freq=1,sum=0,norm=0; for(let i=0;i<oct;i++){ sum+=smooth2(x*freq/scale,y*freq/scale)*amp; norm+=amp; amp*=0.5; freq*=2;} return sum/norm; }
function fractal3(x,y,z){ return (fractal2(x,y,3,24)+fractal2(y,z,3,24)+fractal2(x,z,3,24))/3; }

function genWorld(){
  blocks.fill(AIR);
  for(let z=0;z<D;z++){
    for(let x=0;x<W;x++){
      let n = fractal2(x*0.6,z*0.6,5,32)*6 + fractal2(x*0.08,z*0.08,3,1)*10;
      const centerBias=(1 - Math.hypot(x/W-0.5,z/D-0.5)/0.7071)*3.5;
      n+=centerBias;
      let h=Math.floor(H/4 + n);
      h = Math.max(2, Math.min(H-6,h));
      for(let y=0;y<=h;y++){
        if(y<h-3) setBlock(x,y,z,STONE);
        else if(y<h-1) setBlock(x,y,z,DIRT);
        else setBlock(x,y,z,GRASS);
      }
    }
  }
  for(let z=2;z<D-2;z++) for(let x=2;x<W-2;x++) for(let y=2;y<H-6;y++){
    const n = fractal3(x*0.12,y*0.12,z*0.12);
    const thr = 0.22 + (y/H)*0.4;
    if(n>thr) setBlock(x,y,z,AIR);
  }
  for(let z=2;z<D-2;z++) for(let x=2;x<W-2;x++){
    if(Math.random()<0.007){
      for(let y=H-2;y>1;y--){
        if(getBlock(x,y,z)===GRASS){
          const h=3+Math.floor(Math.random()*2);
          let ok=true;
          for(let yy=y+1;yy<=y+h+2;yy++) for(let lx=-2;lx<=2;lx++) for(let lz=-2;lz<=2;lz++){
            if(getBlock(x+lx,yy,z+lz)!==AIR) ok=false;
          }
          if(!ok) break;
          for(let t=1;t<=h;t++) setBlock(x,y+t,z,LOG);
          for(let lx=-2;lx<=2;lx++) for(let lz=-2;lz<=2;lz++) for(let ly=h-1;ly<=h+1;ly++){
            const ax=x+lx, ay=y+ly+1, az=z+lz;
            if(Math.abs(lx)+Math.abs(lz)+Math.abs(ly) <=4 && getBlock(ax,ay,az)===AIR) setBlock(ax,ay,az,LEAF);
          }
          break;
        }
      }
    }
  }
}
genWorld();

/* ---------- PLAYER ---------- */
let px=0.5, py=0.0, pz=0.5;
(function findSpawn(){
  for(let z=2;z<D-2;z++){
    for(let x=2;x<W-2;x++){
      for(let y=H-6;y>=2;y--){
        const bBelow=getBlock(x,y-1,z), bHere=getBlock(x,y,z), bAbove=getBlock(x,y+1,z);
        if(bBelow!==AIR && bHere===AIR && bAbove===AIR){ px=x+0.5; py=y+0.6; pz=z+0.5; return; }
      }
    }
  }
  px=4.5;py=10.6;pz=4.5;
})();
let yaw=0,pitch=0;
let vy=0; let grounded=false;

const PR = 0.25, PH = 1.6;

/* ---------- CANVAS & FAV ---------- */
const canvas=document.getElementById('view'), ctx=canvas.getContext('2d');
const fav=document.createElement('canvas'); fav.width=FAV; fav.height=FAV; const fctx=fav.getContext('2d');
canvas.style.cursor='crosshair';

/* ---------- INPUT ---------- */
const keys={};
window.addEventListener('keydown', e=>{ keys[e.key]=true; });
window.addEventListener('keyup', e=> keys[e.key]=false);
canvas.addEventListener('click', ()=> canvas.requestPointerLock());
window.addEventListener('mousemove', e=> {
  if(document.pointerLockElement === canvas){
    yaw -= e.movementX * 0.0024;
    pitch -= e.movementY * 0.0024;
    pitch = Math.max(-1.35, Math.min(1.35, pitch));
  }
});

/* ---------- COLLISION ---------- */
function collidesAt(x,y,z){
  const minX = Math.floor(x - PR), maxX = Math.floor(x + PR);
  const minZ = Math.floor(z - PR), maxZ = Math.floor(z + PR);
  const minY = Math.floor(y + 0.001), maxY = Math.floor(y + PH - 0.001);
  for(let bx=minX; bx<=maxX; bx++){
    for(let bz=minZ; bz<=maxZ; bz++){
      for(let by=minY; by<=maxY; by++){
        if(getBlock(bx,by,bz)!==AIR) return true;
      }
    }
  }
  return false;
}

/* ---------- MOVEMENT ---------- */
function movementStep(dt){
  const speed = keys['Shift'] ? 0.16 : 0.09;
  let dx=0,dz=0;
  if(keys['w']||keys['W']) { dx += Math.cos(yaw)*speed; dz += Math.sin(yaw)*speed; }
  if(keys['s']||keys['S']) { dx -= Math.cos(yaw)*speed; dz -= Math.sin(yaw)*speed; }
  if(keys['a']||keys['A']) { dx += Math.sin(yaw)*speed; dz -= Math.cos(yaw)*speed; }
  if(keys['d']||keys['D']) { dx -= Math.sin(yaw)*speed; dz += Math.cos(yaw)*speed; }

  const nx = px + dx;
  if(!collidesAt(nx, py, pz)) px = nx;
  const nz = pz + dz;
  if(!collidesAt(px, py, nz)) pz = nz;

  const GRAV = -9.8;
  vy += GRAV * dt;
  if((keys[' ']||keys['Space']) && grounded){
    vy = 5.2; grounded = false;
  }

  let newY = py + vy * dt;

  /* -------------------------
     FIXED FALLING COLLISION
     ------------------------- */
  if (vy <= 0) {
    const bottomOld = py;
    const bottomNew = newY;

    const probeY = Math.floor(bottomOld - 0.01);
    const blockBelow = getBlock(Math.floor(px), probeY - 1, Math.floor(pz));

    if (!collidesAt(px, newY, pz)) {
      py = newY;
      grounded = false;
    } else {
      py = probeY;
      vy = 0;
      grounded = true;
    }

  } else {
    if(collidesAt(px, newY + PH - 0.001, pz)){
      vy = 0;
    } else {
      py = newY;
      grounded = false;
    }
  }
}

/* ---------- RAYCAST + CAMERA (unchanged) ---------- */
/* ... unchanged raycast & render code ... EXACTLY your original ... */

/* (I’m keeping it intact so your renderer & mining are untouched.) */

</script>
</body>
</html>
