<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Voxel — Fast Minecraft Camera</title>
<style>
    body {
        background:#071018;
        margin:0;
        color:white;
        text-align:center;
        font-family:sans-serif;
    }
    canvas {
        display:block;
        margin:20px auto;
        background:black;
        border:4px solid #123;
    }
</style>
</head>
<body>
<h1>Voxel — Fast Minecraft Camera (No Roll)</h1>
<canvas id="c" width="600" height="400"></canvas>

<script>
// ----------------------------
// CONFIG
// ----------------------------
const CANVAS_W = 600;
const CANVAS_H = 400;
const FOV = Math.PI / 3; // 60°
const STEP = 0.1;        // ray step size
const MAX_DIST = 30;

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
const img = ctx.getImageData(0,0,CANVAS_W,CANVAS_H);
const pix = img.data;

// ---------------------------------
// WORLD (simple flat test terrain)
// ---------------------------------
function blockAt(x,y,z){
    if(y < 0) return 1;
    if(y < 1) return 1;
    return 0;
}

// ---------------------------------
// CAMERA VARIABLES
// ---------------------------------
let px = 0, py = 2, pz = 0;
let yaw = 0;
let pitch = 0;

let mouseLocked = false;

canvas.onclick = () => {
    canvas.requestPointerLock();
};

document.addEventListener("pointerlockchange", ()=>{
    mouseLocked = (document.pointerLockElement === canvas);
});

document.addEventListener("mousemove", e=>{
    if(!mouseLocked) return;

    yaw   += e.movementX * 0.002;
    pitch -= e.movementY * 0.002;

    const limit = Math.PI/2 - 0.001;
    if(pitch > limit) pitch = limit;
    if(pitch < -limit) pitch = -limit;
});

// ---------------------------------
// VECTORS / CAMERA BASIS
// ---------------------------------
function cross(a,b){
    return {
        x: a.y*b.z - a.z*b.y,
        y: a.z*b.x - a.x*b.z,
        z: a.x*b.y - a.y*b.x
    };
}
function normalize(v){
    const L = Math.hypot(v.x,v.y,v.z) || 1;
    return { x:v.x/L, y:v.y/L, z:v.z/L };
}

// ⭐ CORRECTED CAMERA RAY DIRECTION — no roll, no flipping
function cameraRayDir(pxScr, pyScr){
    const nx = (pxScr - CANVAS_W/2) / (CANVAS_W/2);
    const ny = (CANVAS_H/2 - pyScr) / (CANVAS_H/2);

    const sx = Math.tan(FOV/2) * nx;
    const sy = Math.tan(FOV/2) * ny;

    const forward = {
        x: Math.cos(pitch)*Math.cos(yaw),
        y: Math.sin(pitch),
        z: Math.cos(pitch)*Math.sin(yaw)
    };

    const worldUp = {x:0,y:1,z:0};

    // RIGHT-HANDED basis (FIXED)
    let right = normalize(cross(forward, worldUp));
    let up    = normalize(cross(right, forward));

    let d = {
        x: forward.x + right.x*sx + up.x*sy,
        y: forward.y + right.y*sx + up.y*sy,
        z: forward.z + right.z*sx + up.z*sy
    };
    const L = Math.hypot(d.x,d.y,d.z)||1;
    d.x/=L; d.y/=L; d.z/=L;
    return d;
}

// ---------------------------------
// MOVEMENT
// ---------------------------------
const keys = {};
document.addEventListener("keydown", e=>keys[e.key]=1);
document.addEventListener("keyup", e=>keys[e.key]=0);

function movePlayer(dt){
    const speed = 4;

    const forward = {
        x: Math.cos(yaw),
        z: Math.sin(yaw)
    };
    const right = {
        x: Math.sin(yaw),
        z: -Math.cos(yaw)
    };

    if(keys["w"]) { px += forward.x*speed*dt; pz += forward.z*speed*dt; }
    if(keys["s"]) { px -= forward.x*speed*dt; pz -= forward.z*speed*dt; }
    if(keys["a"]) { px += right.x*speed*dt;   pz += right.z*speed*dt; }
    if(keys["d"]) { px -= right.x*speed*dt;   pz -= right.z*speed*dt; }

    if(keys[" "]) py += 3*dt;
    if(keys["Shift"]) py -= 3*dt;

    if(blockAt(px, py-1.7, pz)) py += 2*dt;
}

// ---------------------------------
// RENDER
// ---------------------------------
function render(){
    for(let y=0; y<CANVAS_H; y++){
        for(let x=0; x<CANVAS_W; x++){

            let dir = cameraRayDir(x,y);
            let rx = px, ry = py, rz = pz;

            let hit = false;
            for(let t=0; t<MAX_DIST; t+=STEP){
                rx += dir.x*STEP;
                ry += dir.y*STEP;
                rz += dir.z*STEP;

                if(blockAt(Math.floor(rx), Math.floor(ry), Math.floor(rz))){
                    hit = true;
                    break;
                }
            }

            const i = (y*CANVAS_W + x)*4;
            if(hit){
                pix[i]   = 60 + dir.y*70;
                pix[i+1] = 180;
                pix[i+2] = 60;
                pix[i+3] = 255;
            } else {
                pix[i] = pix[i+1] = pix[i+2] = 0;
                pix[i+3] = 255;
            }
        }
    }

    ctx.putImageData(img,0,0);
}

// ---------------------------------
// LOOP
// ---------------------------------
let last = performance.now();
function loop(t){
    const dt = (t-last)/1000;
    last = t;

    movePlayer(dt);
    render();

    requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

</script>
</body>
</html>
