<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Voxel — True 3D (No Roll / No Flip)</title>
<style>
    body {
        margin: 0;
        background: #061018;
        color: white;
        text-align: center;
        font-family: monospace;
        overflow: hidden;
    }
    #view {
        border: 4px solid #1a2a34;
        margin-top: 20px;
        image-rendering: pixelated;
    }
</style>
</head>
<body>

<h1>Voxel — True 3D (NO ROLL, NO FLIP)</h1>
<canvas id="view" width="240" height="160"></canvas>
<p>WASD move • Mouse look • Space jump • LMB mine • I = inventory • H = health</p>

<script>
// ============================================================
// WORLD CONSTANTS
// ============================================================

const W = 64, D = 64, H = 64;
const CANVAS_W = 240, CANVAS_H = 160;
const FOV = Math.PI/3;
const REACH = 6;

// Block types
const AIR=0, STONE=1, DIRT=2, GRASS=3, LOG=4, LEAF=5;

const blocks = new Uint8Array(W*H*D);
function idx(x,y,z){ return ((y*D)+z)*W + x; }
function inBounds(x,y,z){ return x>=0 && y>=0 && z>=0 && x<W && y<H && z<D; }
function getBlock(x,y,z){ return inBounds(x,y,z) ? blocks[idx(x,y,z)] : STONE; }
function setBlock(x,y,z,v){ if(inBounds(x,y,z)) blocks[idx(x,y,z)] = v; }

// ============================================================
// WORLD GENERATION
// ============================================================

function pseudo(i){ i=(i<<13)^i; return 1.0 - ((i*(i*i*15731+789221)+1376312589)&0x7fffffff)/1073741824.0; }
function smooth2(x,y){
    let xi=Math.floor(x), yi=Math.floor(y);
    let xf=x-xi, yf=y-yi;
    let v00=pseudo(xi+yi*57), v10=pseudo(xi+1+yi*57);
    let v01=pseudo(xi+(yi+1)*57), v11=pseudo(xi+1+(yi+1)*57);
    let u=xf*xf*(3-2*xf), v=yf*yf*(3-2*yf);
    let a=v00*(1-u)+v10*u;
    let b=v01*(1-u)+v11*u;
    return a*(1-v)+b*v;
}
function fractal2(x,y,oct=4,scale=1){
    let amp=1,freq=1,sum=0,norm=0;
    for(let i=0;i<oct;i++){
        sum+=smooth2(x*freq/scale,y*freq/scale)*amp;
        norm+=amp; amp*=0.5; freq*=2;
    }
    return sum/norm;
}
function fractal3(x,y,z){
    return (fractal2(x,y,3,24)+fractal2(y,z,3,24)+fractal2(x,z,3,24))/3;
}

function genWorld(){
    blocks.fill(AIR);

    // heightmap
    for(let z=0;z<D;z++){
        for(let x=0;x<W;x++){
            let n = fractal2(x*0.6,z*0.6,5,32)*6
                  + fractal2(x*0.08,z*0.08,3,1)*10;

            let centerBias = (1 - Math.hypot(x/W-0.5,z/D-0.5)/0.707) * 3.5;
            n += centerBias;

            let h = Math.floor(H/4 + n);
            h = Math.max(2, Math.min(H-6, h));

            for(let y=0;y<=h;y++){
                if(y<h-3) setBlock(x,y,z,STONE);
                else if(y<h-1) setBlock(x,y,z,DIRT);
                else setBlock(x,y,z,GRASS);
            }
        }
    }

    // caves
    for(let z=2;z<D-2;z++)
    for(let x=2;x<W-2;x++)
    for(let y=2;y<H-6;y++){
        let n = fractal3(x*0.12,y*0.12,z*0.12);
        let thr = 0.22 + (y/H)*0.4;
        if(n > thr) setBlock(x,y,z,AIR);
    }

    // trees
    for(let z=2;z<D-2;z++)
    for(let x=2;x<W-2;x++){
        if(Math.random() < 0.009){
            for(let y=H-2;y>1;y--){
                if(getBlock(x,y,z) === GRASS){
                    let h = 3 + Math.floor(Math.random()*2);
                    let ok = true;

                    for(let yy=y+1;yy<=y+h+2;yy++)
                    for(let lx=-2;lx<=2;lx++)
                    for(let lz=-2;lz<=2;lz++){
                        if(getBlock(x+lx,yy,z+lz) !== AIR) ok=false;
                    }
                    if(!ok) break;

                    for(let t=1;t<=h;t++) setBlock(x,y+t,z,LOG);

                    for(let lx=-2;lx<=2;lx++)
                    for(let lz=-2;lz<=2;lz++)
                    for(let ly=h-1;ly<=h+1;ly++){
                        let ax=x+lx, ay=y+ly+1, az=z+lz;
                        if(Math.abs(lx)+Math.abs(lz)+Math.abs(ly)<=4 && getBlock(ax,ay,az)===AIR)
                            setBlock(ax,ay,az,LEAF);
                    }
                    break;
                }
            }
        }
    }
}
genWorld();

// ============================================================
// PLAYER
// ============================================================

let px=4.5, py=15, pz=4.5;
let yaw=0, pitch=0;
let vy=0;
let grounded=false;

const PR=0.25, PH=1.6;

// ============================================================
// INPUT
// ============================================================

const keys = {};
window.addEventListener('keydown', e=> keys[e.key] = true);
window.addEventListener('keyup',   e=> keys[e.key] = false);

const canvas = document.getElementById("view");
const ctx = canvas.getContext("2d");
canvas.addEventListener("click", ()=> canvas.requestPointerLock());
window.addEventListener("mousemove", e=>{
    if(document.pointerLockElement === canvas){
        yaw -= e.movementX * 0.0024;
        pitch -= e.movementY * 0.0024;
        pitch = Math.max(-1.3, Math.min(1.3, pitch)); // clamp
    }
});

// ============================================================
// MOVEMENT & COLLISION
// ============================================================

function collides(nx,ny,nz){
    for(let x=-PR;x<=PR;x+=PR*2)
    for(let y=0;y<=PH;y+=PH)
    for(let z=-PR;z<=PR;z+=PR*2){
        let bx=Math.floor(nx+x), by=Math.floor(ny+y), bz=Math.floor(nz+z);
        if(getBlock(bx,by,bz) !== AIR) return true;
    }
    return false;
}

function movePlayer(dt){
    let speed = grounded ? 3.5 : 2.8;

    let sx=0,sz=0;
    if(keys['w']){ sx += Math.cos(yaw);  sz += Math.sin(yaw);  }
    if(keys['s']){ sx -= Math.cos(yaw);  sz -= Math.sin(yaw);  }
    if(keys['a']){ sx += Math.cos(yaw-Math.PI/2); sz += Math.sin(yaw-Math.PI/2); }
    if(keys['d']){ sx += Math.cos(yaw+Math.PI/2); sz += Math.sin(yaw+Math.PI/2); }

    let len = Math.hypot(sx,sz);
    if(len>0){ sx/=len; sz/=len; }

    let nx = px + sx*speed*dt;
    let nz = pz + sz*speed*dt;

    if(!collides(nx,py,pz)) px = nx;
    if(!collides(px,py,nz)) pz = nz;

    // gravity
    vy -= 9 * dt;
    let ny = py + vy*dt;

    if(!collides(px,ny,pz)){
        py = ny;
        grounded = false;
    } else {
        if(vy < 0) grounded = true;
        vy = 0;
    }

    if(grounded && keys[' ']){ vy = 5.2; grounded=false; }
}

// ============================================================
// RAYMARCH RENDER (WITH NO FLIP / NO ROLL CAMERA)
// ============================================================

// block colors
const COLORS = {
    0: [0,0,0],
    1: [80,80,90],
    2: [100,70,40],
    3: [30,170,30],
    4: [110,80,40],
    5: [40,160,40]
};

function render(){
    let img = ctx.getImageData(0,0,CANVAS_W,CANVAS_H);
    let data = img.data;

    // CAMERA forward vector (spherical)
    let fx = Math.cos(pitch) * Math.cos(yaw);
    let fy = Math.sin(pitch);
    let fz = Math.cos(pitch) * Math.sin(yaw);

    // RIGHT vector (yaw only)
    let rx = Math.cos(yaw - Math.PI/2);
    let ry = 0;
    let rz = Math.sin(yaw - Math.PI/2);

    // UP = R × F  (keeps zero roll)
    let ux = ry*fz - rz*fy;
    let uy = rz*fx - rx*fz;
    let uz = rx*fy - ry*fx;

    let fl = Math.tan(FOV/2);

    for(let y=0;y<CANVAS_H;y++){
        for(let x=0;x<CANVAS_W;x++){

            let u = (x/CANVAS_W)*2 - 1;
            let v = (y/CANVAS_H)*2 - 1;

            // Combine rays
            let dx = fx + u*fl*rx + v*fl*ux;
            let dy = fy + u*fl*ry + v*fl*uy;
            let dz = fz + u*fl*rz + v*fl*uz;

            let L = Math.hypot(dx,dy,dz);
            dx/=L; dy/=L; dz/=L;

            // Raymarch through grid
            let t = 0;
            let hit = 0;

            let stepx = dx>0?1:-1;
            let stepy = dy>0?1:-1;
            let stepz = dz>0?1:-1;

            let bx = Math.floor(px);
            let by = Math.floor(py);
            let bz = Math.floor(pz);

            let maxDist = REACH;

            for(let steps=0;steps<200;steps++){
                if(t > maxDist) break;

                let b = getBlock(bx,by,bz);
                if(b !== AIR){
                    hit = b;
                    break;
                }

                let tx = ((dx>0?bx+1:bx)-px)/dx;
                let ty = ((dy>0?by+1:by)-py)/dy;
                let tz = ((dz>0?bz+1:bz)-pz)/dz;

                let m = Math.min(tx,ty,tz);
                t = m;

                if(tx === m) bx += stepx;
                if(ty === m) by += stepy;
                if(tz === m) bz += stepz;
            }

            let index = (y*CANVAS_W + x)*4;

            if(hit === 0){
                data[index]   = 50;
                data[index+1] = 60;
                data[index+2] = 70;
                data[index+3] = 255;
            } else {
                let c = COLORS[hit];
                data[index]   = c[0];
                data[index+1] = c[1];
                data[index+2] = c[2];
                data[index+3] = 255;
            }
        }
    }
    ctx.putImageData(img,0,0);
}

// ============================================================
// GAME LOOP
// ============================================================

let last = performance.now();
function loop(t){
    let dt = (t-last)/1000;
    last = t;

    movePlayer(dt);
    render();

    requestAnimationFrame(loop);
}
loop(performance.now());

</script>
</body>
</html>
