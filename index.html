<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Raycast (loading...)</title>
<link id="favicon" rel="icon" href="">
<style>
  :root{--bg:#071018;--muted:#9fb7c9}
  html,body{height:100%;margin:0;background:var(--bg);color:#e6f3fb;font-family:Inter,Arial,Helvetica,sans-serif}
  .wrap{display:flex;flex-direction:column;align-items:center;padding:18px}
  h1{margin:8px 0 10px 0}
  canvas#view{width:640px;height:420px;border:4px solid #0f2130; image-rendering: pixelated; background:#000; display:block}
  .hint{color:var(--muted);margin-top:8px;font-size:13px;text-align:center}
  .small{font-size:12px;color:#7f9cae;margin-top:8px}
  code{background:#08202a;padding:2px 6px;border-radius:4px}
</style>
</head>
<body>
  <div class="wrap">
    <h1>Raycast Cave — Fake 3D</h1>
    <canvas id="view" width="320" height="210"></canvas>
    <div class="hint">WASD move • Mouse look (click canvas) • Arrow keys look • Space jump • LMB mine • I = inventory title • H = health title</div>
    <div class="small">Edit the <code>map</code> array in the script to make your own levels</div>
  </div>

<script>
/* ============================
   Raycast engine (fake 3D)
   - DDA 2D raycast
   - look up/down (pitch), jumping (camera height)
   - wall collision
   - mining (remove wall cell)
   - inventory & health in title
   - favicon mirror
   ============================ */

/* =========== CONFIG ============ */
const MAP = [
  // 0 = empty, 1 = wall (solid)
  // 20x12 example; edit to your liking (must be rectangular)
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,2,0,0,0,1,0,1,0,0,0,3,0,0,0,1],
  [1,0,0,0,0,2,0,0,0,1,0,1,0,0,0,3,0,0,0,1],
  [1,0,0,0,0,2,0,0,0,1,0,1,0,0,0,3,0,0,0,1],
  [1,0,0,0,0,0,0,4,0,1,0,1,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,4,0,1,0,1,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,4,0,1,0,1,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];
// note: map values >0 are considered walls; numbers can encode variant types (for inventory naming)
const MAP_W = MAP[0].length;
const MAP_H = MAP.length;

/* rendering sizes */
const CANVAS = document.getElementById('view');
const CTX = CANVAS.getContext('2d');
const VIEW_W = CANVAS.width;   // 320
const VIEW_H = CANVAS.height;  // 210
const HALF_W = VIEW_W/2, HALF_H = VIEW_H/2;
const FOV = Math.PI/3; // 60deg
const NUM_RAYS = VIEW_W; // 1 column per pixel
const MAX_DIST = 20;

/* favicon */
const FAV = document.createElement('canvas'); FAV.width = 16; FAV.height = 16;
const FCTX = FAV.getContext('2d');

/* player state */
let px = 3.5, pz = 3.5;   // x,z in map
let py = 0.5;            // camera height (y)
let vy = 0;              // vertical velocity
let yaw = 0;             // heading (radians)
let pitch = 0;           // look up/down (radians) - affects vertical offset of wall rendering
let grounded = false;

const MOVE_SPEED = 3.0; // units/sec
const JUMP_SPEED = 5.5;
const GRAV = 18.0;      // units/sec^2

/* controls */
const keys = {};
window.addEventListener('keydown', e=>{ keys[e.key] = true; if (e.key==='i'||e.key==='I'){ showInv=!showInv; updateTitle(); } if (e.key==='h'||e.key==='H'){ showHealth=!showHealth; updateTitle(); }});
window.addEventListener('keyup', e=> keys[e.key]=false);

/* mouse look (pointer lock) */
CANVAS.addEventListener('click', ()=> CANVAS.requestPointerLock && CANVAS.requestPointerLock());
window.addEventListener('pointerlockchange', ()=>{/* nothing */});
window.addEventListener('mousemove', e=>{
  if (document.pointerLockElement === CANVAS){
    yaw += -e.movementX * 0.0025;
    pitch += -e.movementY * 0.0025;
    pitch = Math.max(-0.8, Math.min(0.8, pitch));
  }
});

/* inventory & health */
const inventory = {};    // id -> count
let health = 20;
let showInv = false, showHealth = false;
function addInv(id){ inventory[id] = (inventory[id]||0) + 1; updateTitle(); }
function idName(id){
  if (id===1) return "stone";
  if (id===2) return "ore";
  if (id===3) return "dirt";
  if (id===4) return "wood";
  return "block";
}
function updateTitle(){
  const parts = [];
  if (showInv){
    const items = Object.keys(inventory).map(k => `${idName(Number(k))} x${inventory[k]}`).join(", ");
    parts.push("Inv: " + (items||"empty"));
  }
  if (showHealth) parts.push(`Health: ${health}`);
  document.title = parts.length ? parts.join(" | ") : "Raycast Cave";
}

/* mining (mouse left) */
window.addEventListener('mousedown', e=>{
  if (e.button === 0) mineAtCenter();
});

/* =========== UTILITIES =========== */
function mapAt(x,z){
  const xi = Math.floor(x), zi = Math.floor(z);
  if (xi < 0 || zi < 0 || xi >= MAP_W || zi >= MAP_H) return 1;
  return MAP[zi][xi];
}
function isSolidAt(x,z){
  return mapAt(x,z) !== 0;
}

/* DDA raycast in 2D grid returning first wall hit {mapX,mapZ,distance,hitX,hitZ,side} */
function castRay2D(rx, rz, angle, maxD=MAX_DIST){
  // ray origin rx,rz; direction vector
  const dx = Math.cos(angle), dz = Math.sin(angle);
  // current map square
  let mapX = Math.floor(rx);
  let mapZ = Math.floor(rz);

  // length of ray from one x or z-side to next
  const deltaDistX = Math.abs(1 / dx);
  const deltaDistZ = Math.abs(1 / dz);

  // step and initial sideDist
  let stepX = dx < 0 ? -1 : 1;
  let stepZ = dz < 0 ? -1 : 1;
  let sideDistX, sideDistZ;

  if (dx < 0) sideDistX = (rx - mapX) * deltaDistX;
  else sideDistX = (mapX + 1.0 - rx) * deltaDistX;
  if (dz < 0) sideDistZ = (rz - mapZ) * deltaDistZ;
  else sideDistZ = (mapZ + 1.0 - rz) * deltaDistZ;

  let side = 0; // 0 = hit x-side, 1 = hit z-side
  let dist = 0;

  while (dist < maxD){
    if (sideDistX < sideDistZ){
      sideDistX += deltaDistX;
      mapX += stepX;
      side = 0;
      dist = sideDistX - deltaDistX;
    } else {
      sideDistZ += deltaDistZ;
      mapZ += stepZ;
      side = 1;
      dist = sideDistZ - deltaDistZ;
    }
    // out of bounds -> treat as wall
    if (mapX < 0 || mapZ < 0 || mapX >= MAP_W || mapZ >= MAP_H){
      return {mapX, mapZ, distance: dist, side, hitX: rx + dx * dist, hitZ: rz + dz * dist};
    }
    if (MAP[mapZ][mapX] !== 0){
      return {mapX, mapZ, distance: dist, side, hitX: rx + dx * dist, hitZ: rz + dz * dist};
    }
  }
  return null;
}

/* =========== MOVEMENT & COLLISION =========== */
/* We use simple axis-aligned collision — before applying move, test target tile(s).
   Player represented as circle with radius PLAYER_R. If tile at target position is solid -> block movement.
*/
const PLAYER_R = 0.28;
function canMoveTo(nx, nz){
  // check several sample points around circle
  const samples = [
    [0,0],
    [PLAYER_R, 0],
    [-PLAYER_R, 0],
    [0, PLAYER_R],
    [0, -PLAYER_R],
    [PLAYER_R*0.7, PLAYER_R*0.7],
    [-PLAYER_R*0.7, PLAYER_R*0.7],
    [PLAYER_R*0.7, -PLAYER_R*0.7],
    [-PLAYER_R*0.7, -PLAYER_R*0.7]
  ];
  for (const s of samples){
    const sx = nx + s[0], sz = nz + s[1];
    if (isSolidAt(sx, sz)) return false;
  }
  return true;
}

/* =========== JUMP / VERTICAL =========== */
let jumpRequested = false;
window.addEventListener('keydown', e=>{
  if (e.code === 'Space') { jumpRequested = true; e.preventDefault(); }
});
function updateVertical(dt){
  // if on ground and jump requested -> apply vy
  if (grounded && jumpRequested){
    vy = JUMP_SPEED;
    grounded = false;
  }
  jumpRequested = false;
  // integrate
  vy -= GRAV * dt;
  py += vy * dt;
  // ground check: if camera height below floor height (we keep floor at y=0)
  if (py <= 0.5){ // floor baseline (0 = floor top)
    py = 0.5;
    vy = 0;
    grounded = true;
  }
  // NOTE: walls are vertical columns; jumping doesn't let you pass through a wall.
}

/* =========== MINING =========== */
function mineAtCenter(){
  // cast a ray from player horizontally in yaw direction, find first wall within reach
  const originX = px, originZ = pz;
  const dir = {x: Math.cos(yaw), z: Math.sin(yaw)};
  const hit = castRay2D(originX, originZ, yaw, REACH);
  if (!hit) return;
  // remove block, add to inventory
  const id = MAP[hit.mapZ][hit.mapX];
  if (id !== 0){
    addInv(id);
    MAP[hit.mapZ][hit.mapX] = 0;
  }
}

/* =========== RENDERING =========== */
function render(){
  // clear sky+floor
  const skyGrad = CTX.createLinearGradient(0,0,0,HALF_H);
  skyGrad.addColorStop(0, '#89c2ff');
  skyGrad.addColorStop(1, '#1f2840');
  CTX.fillStyle = skyGrad;
  CTX.fillRect(0,0,VIEW_W, HALF_H);

  CTX.fillStyle = '#2d2d2d'; // floor color
  CTX.fillRect(0, HALF_H, VIEW_W, HALF_H);

  // for each column, cast ray and draw vertical slice
  for (let x = 0; x < NUM_RAYS; x++){
    // camera plane mapping from column to angle offset
    const cameraX = (2 * x / NUM_RAYS) - 1; // -1 .. 1
    const rayAngle = yaw + Math.atan(cameraX * Math.tan(FOV/2));
    const hit = castRay2D(px, pz, rayAngle, MAX_DIST);
    if (!hit) continue;

    let dist = hit.distance;
    // correct fisheye by multiplying by cos between ray and yaw
    const angDiff = normalizeAngle(rayAngle - yaw);
    dist *= Math.cos(angDiff);

    // wall height on screen
    const wallHeight = Math.min(VIEW_H*2, (VIEW_H * 1.0) / (dist + 0.0001));

    // vertical offset due to pitch & jump (pitch moves the view up/down)
    const verticalOffset = (pitch * 80) + (py - 0.5) * 60; // tweak multipliers for feel

    // compute slice positions
    const yTop = Math.round(HALF_H - wallHeight/2 + verticalOffset);
    const yBottom = Math.round(HALF_H + wallHeight/2 + verticalOffset);

    // shade color depending on block id and side
    const id = MAP[hit.mapZ][hit.mapX];
    let color = '#888888';
    if (id === 1) color = '#8d8d8d';
    if (id === 2) color = '#b07f3b';
    if (id === 3) color = '#7fa35d';
    if (id === 4) color = '#6b3f24';

    // darker if side (simulate lighting)
    const shadeFactor = hit.side === 1 ? 0.8 : 1.0;
    const shaded = shadeHex(color, shadeFactor);

    // draw vertical slice (1 px wide)
    CTX.fillStyle = shaded;
    CTX.fillRect(x, yTop, 1, Math.max(1, yBottom - yTop));

    // floor/ceiling simple shading: draw a small stripe under wall to indicate floor meeting wall
    CTX.fillStyle = '#111111';
    if (yBottom < VIEW_H) CTX.fillRect(x, yBottom, 1, 1);
  }

  // HUD text
  CTX.fillStyle = 'rgba(0,0,0,0.4)';
  CTX.fillRect(6,6,190,34);
  CTX.fillStyle = '#fff';
  CTX.font = '11px monospace';
  CTX.fillText(`Health: ${health}`, 12, 20);
  const invItems = Object.keys(inventory).map(k => `${idName(Number(k))}:${inventory[k]}`).slice(0,5).join(' ');
  CTX.fillText(`Inv: ${invItems || 'empty'}`, 12, 36);

  // center reticle
  CTX.strokeStyle = 'rgba(255,255,255,0.6)';
  CTX.beginPath();
  CTX.moveTo(HALF_W-6, HALF_H); CTX.lineTo(HALF_W+6, HALF_H);
  CTX.moveTo(HALF_W, HALF_H-6); CTX.lineTo(HALF_W, HALF_H+6);
  CTX.stroke();

  // favicon mirror (fast downscale)
  FCTX.imageSmoothingEnabled = false;
  FCTX.drawImage(CANVAS, 0, 0, FAV.width, FAV.height);
  document.getElementById('favicon').href = FAV.toDataURL('image/png');
}

/* =========== MAIN LOOP =========== */
let last = performance.now();
function loop(now){
  const t = performance.now();
  const dt = Math.min(0.05, (t - last) / 1000);
  last = t;

  // handle movement input
  let mvx = 0, mvz = 0;
  const spd = (keys['Shift'] ? MOVE_SPEED*1.6 : MOVE_SPEED);
  if (keys['w'] || keys['W']) { mvx += Math.cos(yaw) * spd * dt; mvz += Math.sin(yaw) * spd * dt; }
  if (keys['s'] || keys['S']) { mvx -= Math.cos(yaw) * spd * dt; mvz -= Math.sin(yaw) * spd * dt; }
  if (keys['a'] || keys['A']) { mvx += Math.sin(yaw) * spd * dt; mvz -= Math.cos(yaw) * spd * dt; }
  if (keys['d'] || keys['D']) { mvx -= Math.sin(yaw) * spd * dt; mvz += Math.cos(yaw) * spd * dt; }

  // try move with collision checks
  if (mvx !== 0 || mvz !== 0){
    const tryX = px + mvx, tryZ = pz;
    if (canMoveTo(tryX, tryZ)) { px = tryX; }
    const tryZ2 = pz + mvz, tryX2 = px;
    if (canMoveTo(tryX2, tryZ2)) { pz = tryZ2; }
  }

  // vertical update (gravity / jump)
  updateVertical(dt);

  // look with arrow keys (fallback if not using pointer)
  if (keys['ArrowLeft']) yaw -= 1.6 * dt;
  if (keys['ArrowRight']) yaw += 1.6 * dt;
  if (keys['ArrowUp']) pitch = clamp(pitch - 1.6 * dt, -0.8, 0.8);
  if (keys['ArrowDown']) pitch = clamp(pitch + 1.6 * dt, -0.8, 0.8);

  render();

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* =========== MISC HELPERS =========== */
function normalizeAngle(a){
  while (a < -Math.PI) a += Math.PI*2;
  while (a > Math.PI) a -= Math.PI*2;
  return a;
}
function shadeHex(hex, factor){
  const r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
  const nr = Math.max(0, Math.min(255, Math.round(r * factor)));
  const ng = Math.max(0, Math.min(255, Math.round(g * factor)));
  const nb = Math.max(0, Math.min(255, Math.round(b * factor)));
  return '#' + [nr,ng,nb].map(n=>n.toString(16).padStart(2,'0')).join('');
}

/* =========== INITIAL TITLE =========== */
updateTitle();

/* =========== Export for debug in console (optional) =========== */
window.raycastDebug = {
  MAP,
  get player(){ return {x:px, y:py, z:pz, yaw, pitch}; },
  castRay2D,
  mineAtCenter
};
</script>
</body>
</html>
