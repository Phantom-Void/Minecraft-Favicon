<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Open Grassland — Loading...</title>
<link id="favicon" rel="icon" href="">
<style>
  :root{--bg:#071018;--muted:#9fb7c9}
  html,body{height:100%;margin:0;background:var(--bg);color:#e6f3fb;font-family:Inter,Arial,Helvetica,sans-serif}
  .wrap{display:flex;flex-direction:column;align-items:center;padding:14px}
  h1{margin:8px 0 10px 0}
  canvas#view{width:720px;height:480px;border:4px solid #0f2130; image-rendering: pixelated; background:#000; display:block}
  .hint{color:var(--muted);margin-top:8px;font-size:13px;text-align:center}
  .small{font-size:12px;color:#7f9cae;margin-top:8px}
  code{background:#08202a;padding:2px 6px;border-radius:4px}
</style>
</head>
<body>
  <div class="wrap">
    <h1>Open Grassland (Raycast Heightmap)</h1>
    <canvas id="view" width="360" height="240"></canvas>
    <div class="hint">WASD = move • Mouse look (click canvas) • Arrow keys look • Space = jump • LMB = mine • I = inv title • H = health title</div>
    <div class="small">64×64 heightmap world • Trees & caves • Mining drops blocks into inventory</div>
  </div>

<script>
/* ============================
  Raycast heightmap world — fixed & working
  - Fixes: duplicate var removal, persistent eye offset, proper jump/landing, integrated camera bob
  ============================ */

/* CONFIG */
const SIZE = 64;              // world size (x,z)
const VIEW_W = 360, VIEW_H = 240;
const HALF_W = VIEW_W/2, HALF_H = VIEW_H/2;
const FOV = Math.PI/3;
const REACH = 6;              // mining range
const PLAYER_EYE = 1.6;       // player eye height above ground
const STEP_MAX = 0.9;         // max permitted vertical difference to step onto
const MOVE_SPEED = 3.0;       // world units/second
const JUMP_V = 5.2;
const GRAV = 18.0;
const FAV_SIZE = 16;

/* block codes (for inventory naming) */
const AIR = 0, STONE = 1, DIRT = 2, GRASS = 3, WOOD = 4, LEAF = 5;

/* canvas */
const canvas = document.getElementById('view');
const ctx = canvas.getContext('2d');
const fav = document.createElement('canvas'); fav.width = FAV_SIZE; fav.height = FAV_SIZE;
const fctx = fav.getContext('2d');

/* world data structures */
const HEIGHT = []; // HEIGHT[z][x] integer height (0..HMAX)
const TYPE = [];   // TYPE[z][x] top block type (grass/dirt/stone/wood/leaf)
const trees = [];  // tree sprites {x,z,h}

const HMAX = 20;   // practical maximum terrain height for display and generation

for (let z=0; z<SIZE; z++){
  HEIGHT[z]=new Array(SIZE).fill(0);
  TYPE[z]=new Array(SIZE).fill(AIR);
}

/* small PRNG helpers */
function rand(min,max){ return Math.random()*(max-min)+min; }
function randint(a,b){ return Math.floor(rand(a,b+1)); }

/* noise / heightmap */
function smoothNoise(x,y){
  const xi = Math.floor(x), yi = Math.floor(y);
  const xf = x - xi, yf = y - yi;
  function ph(i){ i = (i<<13)^i; return 1 - ((i*(i*i*15731+789221)+1376312589)&0x7fffffff)/1073741824.0; }
  const v00 = ph(xi+yi*57), v10 = ph(xi+1+yi*57), v01 = ph(xi+(yi+1)*57), v11 = ph(xi+1+(yi+1)*57);
  const u = xf*xf*(3-2*xf), v = yf*yf*(3-2*yf);
  const a = v00*(1-u)+v10*u;
  const b = v01*(1-u)+v11*u;
  return a*(1-v)+b*v;
}
function fractal(x,y,oct=4,scale=1){
  let amp=1,f=1,sum=0,norm=0;
  for(let i=0;i<oct;i++){ sum += smoothNoise(x*f/scale,y*f/scale)*amp; norm+=amp; amp*=0.5; f*=2; }
  return sum/norm;
}

/* generate open grassy world with caves & trees */
function genWorld(){
  // heights
  for (let z=0; z<SIZE; z++){
    for (let x=0; x<SIZE; x++){
      // multi-octave patterns + center bias
      const n = fractal(x*0.08, z*0.08,4,12)*6
              + fractal(x*0.02, z*0.02,3,1)*8;
      const center = (1 - Math.hypot(x/SIZE-0.5, z/SIZE-0.5)/0.7071) * 4;
      let h = Math.floor(8 + n + center);
      h = Math.max(1, Math.min(HMAX-1, h));
      HEIGHT[z][x] = h;
      TYPE[z][x] = (h>0 ? (h>6? DIRT : GRASS) : AIR);
    }
  }

  // carve caves: random walkers carve down heights in patches
  for (let i=0;i<150;i++){
    let cx = randint(2,SIZE-3), cz = randint(2,SIZE-3);
    let len = randint(40,160);
    while(len--){
      // make deeper pocket
      HEIGHT[cz][cx] = Math.max(0, HEIGHT[cz][cx] - randint(1,3));
      cx += randint(-1,1);
      cz += randint(-1,1);
      cx = Math.max(2, Math.min(SIZE-3, cx));
      cz = Math.max(2, Math.min(SIZE-3, cz));
    }
  }

  // place trees on grass
  for (let i=0;i<260;i++){
    const x = randint(2,SIZE-3), z = randint(2,SIZE-3);
    if (TYPE[z][x] !== GRASS) continue;
    // small chance
    if (Math.random() < 0.35) {
      const h = randint(3,5);
      trees.push({x:x+0.5,z:z+0.5,h});
      // mark top block as wood for mining (on same tile)
      TYPE[z][x] = WOOD;
    }
  }

  // set top type mapping: if height very high stone shows
  for (let z=0; z<SIZE; z++){
    for (let x=0; x<SIZE; x++){
      if (HEIGHT[z][x] >= 10) TYPE[z][x] = STONE;
      else if (TYPE[z][x] === AIR) TYPE[z][x] = DIRT;
    }
  }
}
genWorld();

/* player spawn on a decent grass tile */
let playerX=32.5, playerZ=32.5;
function findSpawn(){
  for (let z=2; z<SIZE-2; z++){
    for (let x=2; x<SIZE-2; x++){
      if (TYPE[z][x] === GRASS){
        playerX = x+0.5; playerZ = z+0.5; return;
      }
    }
  }
}
findSpawn();

/* player movement & camera */
let yaw=0, pitch=0;         // yaw yaw, pitch up/down
let velY = 0, onGround = true;   // KEEP single declaration
let playerEyeOffset = 0;    // persistent eye offset for jump/bob
let keys = {};
window.addEventListener('keydown', e=>{ keys[e.key]=true; if (e.key==='i'||e.key==='I'){ showInv=!showInv; updateTitle(); } if (e.key==='h'||e.key==='H'){ showHealth=!showHealth; updateTitle(); }});
window.addEventListener('keyup', e=> keys[e.key]=false);

/* mouse look */
canvas.addEventListener('click', ()=> canvas.requestPointerLock && canvas.requestPointerLock());
window.addEventListener('mousemove', e=>{
  if (document.pointerLockElement === canvas){
    yaw -= e.movementX * 0.0024;
    pitch -= e.movementY * 0.0024;
    pitch = Math.max(-0.85, Math.min(0.85, pitch));
  }
});

/* inventory & health */
const inventory = {};
let health = 20, showInv=false, showHealth=false;
function addInv(code){
  inventory[code] = (inventory[code]||0) + 1;
  updateTitle();
}
function blockName(code){
  switch(code){
    case STONE: return "stone";
    case DIRT: return "dirt";
    case GRASS: return "grass";
    case WOOD: return "wood";
    case LEAF: return "leaf";
    default: return "block";
  }
}
function updateTitle(){
  const parts=[];
  if (showInv){
    const partsI = Object.keys(inventory).map(k => `${blockName(Number(k))} x${inventory[k]}`).join(", ");
    parts.push("Inv: "+(partsI||"empty"));
  }
  if (showHealth) parts.push(`Health: ${health}`);
  document.title = parts.length ? parts.join(" | ") : "Open Grassland";
}

/* collision on heightmap: cannot move into tile where height difference > STEP_MAX */
function tileHeightAt(x,z){
  const xi = Math.floor(x), zi = Math.floor(z);
  if (xi<0||zi<0||xi>=SIZE||zi>=SIZE) return 0;
  return HEIGHT[zi][xi];
}
function canMoveTo(nx,nz){
  const curH = tileHeightAt(playerX, playerZ);
  const tgtH = tileHeightAt(nx, nz);
  if (Math.abs(tgtH - curH) > STEP_MAX) return false;
  // also ensure target within bounds
  const xi = Math.floor(nx), zi = Math.floor(nz);
  if (xi<1||zi<1||xi>=SIZE-1||zi>=SIZE-1) return false;
  return true;
}

/* mining: cast a short horizontal ray and pick the tile; lower its height */
function cast2D(rx, rz, angle, maxD=REACH){
  const dx = Math.cos(angle), dz = Math.sin(angle);
  let mapX = Math.floor(rx), mapZ = Math.floor(rz);
  const deltaDistX = Math.abs(1 / dx);
  const deltaDistZ = Math.abs(1 / dz);
  let stepX = dx < 0 ? -1 : 1;
  let stepZ = dz < 0 ? -1 : 1;
  let sideDistX = dx < 0 ? (rx - mapX) * deltaDistX : (mapX + 1.0 - rx) * deltaDistX;
  let sideDistZ = dz < 0 ? (rz - mapZ) * deltaDistZ : (mapZ + 1.0 - rz) * deltaDistZ;
  let dist = 0;
  let side = 0;
  while (dist < maxD){
    if (sideDistX < sideDistZ){
      sideDistX += deltaDistX;
      mapX += stepX;
      side = 0;
      dist = sideDistX - deltaDistX;
    } else {
      sideDistZ += deltaDistZ;
      mapZ += stepZ;
      side = 1;
      dist = sideDistZ - deltaDistZ;
    }
    if (mapX < 0 || mapZ < 0 || mapX >= SIZE || mapZ >= SIZE) return null;
    // if tile has any non-zero height treat as hittable
    if (HEIGHT[mapZ][mapX] > 0) return {mapX,mapZ,dist,side};
  }
  return null;
}
function mineCenter(){
  const hit = cast2D(playerX, playerZ, yaw, REACH);
  if (!hit) return;
  const x = hit.mapX, z = hit.mapZ;
  if (HEIGHT[z][x] <= 0) return;
  // determine block type from height-ish mapping
  let code = DIRT;
  if (TYPE[z][x] === STONE) code = STONE;
  else if (TYPE[z][x] === WOOD) code = WOOD;
  else if (TYPE[z][x] === LEAF) code = LEAF;
  else if (TYPE[z][x] === GRASS) code = DIRT;
  addInv(code);
  HEIGHT[z][x] = Math.max(0, HEIGHT[z][x] - 1);
  // if we removed a tree top, clear tree (approx)
  TYPE[z][x] = HEIGHT[z][x] > 9 ? STONE : (HEIGHT[z][x] > 0 ? DIRT : AIR);
}

/* handle left click mining */
window.addEventListener('mousedown', (e)=>{
  if (e.button === 0) mineCenter();
});

/* camera / rendering helpers */
function shadeHex(hex, f){
  const r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
  const nr = Math.max(0, Math.min(255, Math.round(r*f)));
  const ng = Math.max(0, Math.min(255, Math.round(g*f)));
  const nb = Math.max(0, Math.min(255, Math.round(b*f)));
  return '#'+[nr,ng,nb].map(n=>n.toString(16).padStart(2,'0')).join('');
}

function lerp(a,b,t){ return a + (b-a)*t; }

/* render loop: raycast per column, compute vertical slice height based on block column top relative to player's eye */
function render(){
  // sky
  const grad = ctx.createLinearGradient(0,0,0,HALF_H);
  grad.addColorStop(0, '#9bd3ff');
  grad.addColorStop(1, '#3a4b6b');
  ctx.fillStyle = grad; ctx.fillRect(0,0,VIEW_W, HALF_H);
  // ground baseline
  ctx.fillStyle = '#3a3a3a'; ctx.fillRect(0, HALF_H, VIEW_W, HALF_H);

  // draw columns/walls
  for (let x=0; x<VIEW_W; x++){
    const cameraX = (2 * x / VIEW_W) - 1;
    const rayAngle = yaw + Math.atan(cameraX * Math.tan(FOV/2));
    // cast in 2D to first column with height
    const hit = cast2D(playerX, playerZ, rayAngle, 80);
    if (!hit){
      // no tile: skip
      continue;
    }
    let dist = hit.dist;
    // fish-eye correction
    const diff = normalizeAngle(rayAngle - yaw);
    dist *= Math.cos(diff);

    // top height of column
    const colH = HEIGHT[hit.mapZ][hit.mapX];
    const topWorldY = colH; // world units
    const playerWorldY = getPlayerGroundY(playerX, playerZ) + PLAYER_EYE + playerEyeOffset; // player's eye y (with offset)

    // compute apparent height on screen: the taller the column above player's eye, the larger slice
    const heightWorld = Math.max(0.01, topWorldY - (playerWorldY - PLAYER_EYE));
    // base scale tuning for look
    const sliceHeight = Math.min(VIEW_H*2, (VIEW_H * 1.5) * (heightWorld / Math.max(0.0001, dist)));
    const yTop = Math.round(HALF_H - sliceHeight/2 - ( (playerWorldY - PLAYER_EYE) - 0 ) * 6); // adjust vertical based on eye
    const yBottom = Math.round(yTop + sliceHeight);

    // color by top type
    const t = TYPE[hit.mapZ][hit.mapX];
    let base = '#8d8d8d';
    if (t === GRASS) base = '#5fb75f';
    if (t === DIRT) base = '#b07f3b';
    if (t === STONE) base = '#8d8d8d';
    if (t === WOOD) base = '#6b3f24';
    if (t === LEAF) base = '#2fa04a';

    // side shading using hit.side
    const shadeFactor = hit.side === 1 ? 0.75 : 1.0;
    ctx.fillStyle = shadeHex(base, shadeFactor);
    ctx.fillRect(x, yTop, 1, Math.max(1, yBottom - yTop));

    // little floor line
    ctx.fillStyle = '#222'; ctx.fillRect(x, Math.min(VIEW_H-1, yBottom), 1, 1);
  }

  // draw tree sprites (simple billboards) sorted by distance back->front
  const sprites = trees.map(s=>{
    const dx = s.x - playerX, dz = s.z - playerZ;
    const dist = Math.hypot(dx, dz);
    return {s, dx, dz, dist};
  }).filter(it=> it.dist < 60);
  sprites.sort((a,b)=> b.dist - a.dist);
  for (const it of sprites){
    const s = it.s;
    // compute angle to sprite relative to camera
    const ang = Math.atan2(s.z - playerZ, s.x - playerX);
    const relAng = normalizeAngle(ang - yaw);
    // if outside FOV skip
    if (Math.abs(relAng) > FOV/2 + 0.6) continue;
    // project: similar idea to column
    const projDist = it.dist * Math.cos(relAng); // frontal distance
    const size = Math.min(120, (VIEW_H * 1.6) / Math.max(0.4, projDist/ (s.h/3)));
    const screenX = Math.round(HALF_W + Math.tan(relAng) * HALF_W / Math.tan(FOV/2));
    // vertical placement using ground height at sprite
    const groundY = getPlayerGroundY(s.x, s.z);
    const eyeY = getPlayerGroundY(playerX, playerZ) + PLAYER_EYE + playerEyeOffset;
    const verticalOffset = (eyeY - groundY) * 6;
    const screenY = Math.round(HALF_H - size/2 - verticalOffset);
    // draw trunk/foliage rectangle
    // trunk
    ctx.fillStyle = '#6b3f24';
    ctx.fillRect(screenX - Math.round(size*0.12), screenY + Math.round(size*0.25), Math.round(size*0.24), Math.round(size*0.5));
    // leaves
    ctx.fillStyle = '#2fa04a';
    ctx.beginPath();
    ctx.ellipse(screenX, screenY, size*0.6, size*0.6, 0, 0, Math.PI*2);
    ctx.fill();
  }

  // HUD
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  ctx.fillRect(6,6,230,36);
  ctx.fillStyle = '#fff'; ctx.font='12px monospace';
  ctx.fillText(`Health: ${health}`, 12, 22);
  const invShort = Object.keys(inventory).map(k=> `${blockName(Number(k))}:${inventory[k]}`).slice(0,6).join(' ');
  ctx.fillText(`Inv: ${invShort || 'empty'}`, 12, 38);

  // reticle
  ctx.strokeStyle = 'rgba(255,255,255,0.7)';
  ctx.beginPath();
  ctx.moveTo(HALF_W-6, HALF_H); ctx.lineTo(HALF_W+6, HALF_H);
  ctx.moveTo(HALF_W, HALF_H-6); ctx.lineTo(HALF_W, HALF_H+6);
  ctx.stroke();

  // favicon mirror
  fctx.imageSmoothingEnabled = false;
  fctx.drawImage(canvas, 0, 0, FAV_SIZE, FAV_SIZE);
  document.getElementById('favicon').href = fav.toDataURL('image/png');
}

/* helper to find ground y at (x,z) */
function getPlayerGroundY(x,z){
  const xi = Math.floor(x), zi = Math.floor(z);
  if (xi<0||zi<0||xi>=SIZE||zi>=SIZE) return 0;
  return HEIGHT[zi][xi];
}

/* game loop: movement, gravity, collision step, render */
let last = performance.now();
function loop(){
  const now = performance.now();
  let dt = Math.min(0.05, (now - last)/1000);
  last = now;

  // rotation fallback via arrow keys
  if (!document.pointerLockElement) {
    if (keys['ArrowLeft']) yaw -= 1.8 * dt;
    if (keys['ArrowRight']) yaw += 1.8 * dt;
    if (keys['ArrowUp']) pitch = Math.max(-0.85, pitch - 1.8 * dt);
    if (keys['ArrowDown']) pitch = Math.min(0.85, pitch + 1.8 * dt);
  }

  // movement
  let mx = 0, mz = 0;
  const sp = (keys['Shift'] ? MOVE_SPEED*1.6 : MOVE_SPEED);
  if (keys['w']||keys['W']) { mx += Math.cos(yaw) * sp * dt; mz += Math.sin(yaw) * sp * dt; }
  if (keys['s']||keys['S']) { mx -= Math.cos(yaw) * sp * dt; mz -= Math.sin(yaw) * sp * dt; }
  if (keys['a']||keys['A']) { mx += Math.sin(yaw) * sp * dt; mz -= Math.cos(yaw) * sp * dt; }
  if (keys['d']||keys['D']) { mx -= Math.sin(yaw) * sp * dt; mz += Math.cos(yaw) * sp * dt; }

  if (mx !== 0 || mz !== 0){
    const tryX = playerX + mx, tryZ = playerZ;
    if (canMoveTo(tryX, tryZ)) playerX = tryX;
    const tryZ2 = playerZ + mz, tryX2 = playerX;
    if (canMoveTo(tryX2, tryZ2)) playerZ = tryZ2;
  }

  // jumping
  if ((keys[' '] || keys['Space']) && onGround){
    velY = JUMP_V;
    onGround = false;
  }

  // gravity + integrate eye offset (visual)
  velY -= GRAV * dt;
  playerEyeOffset += velY * dt;

  // landing detection: when eye offset goes <= 0 (on or below ground level)
  const groundY = getPlayerGroundY(playerX, playerZ);
  if (playerEyeOffset <= 0){
    playerEyeOffset = 0;
    velY = 0;
    onGround = true;
  }

  // render (eye offset used in render via playerEyeOffset)
  render();

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* misc helpers */
function normalizeAngle(a){
  while (a < -Math.PI) a += Math.PI*2;
  while (a > Math.PI) a -= Math.PI*2;
  return a;
}

/* casting & tools for console */
window.worldDebug = { HEIGHT, TYPE, trees, player: ()=>({x:playerX,z:playerZ,y:getPlayerGroundY(playerX,playerZ)}) };

/* initial title */
updateTitle();

</script>
</body>
</html>
