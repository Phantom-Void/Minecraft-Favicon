<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Canvas Voxel (No WebGL) — Favicon + Zoom</title>
<link id="favicon" rel="icon" href="">
<style>
  :root{--bg:#071018;--panel:#0c1720;--muted:#9fb7c9}
  html,body{height:100%;margin:0;background:var(--bg);color:#e6f3fb;font-family:Inter,Arial,Helvetica,sans-serif}
  .wrap{display:flex;flex-direction:column;align-items:center;padding:20px}
  h1{margin:6px 0 12px 0;font-weight:600}
  #view{width:480px;height:480px;border:4px solid #0f2130; image-rendering: pixelated; background:#000}
  .hint{color:var(--muted);margin-top:8px;font-size:13px}
  .credits{color:#7f9cae;margin-top:10px;font-size:12px}
</style>
</head>
<body>
  <div class="wrap">
    <h1>Canvas Voxel — Fake 3D (No WebGL)</h1>
    <canvas id="view" width="240" height="240"></canvas>
    <div class="hint">WASD = move • Arrow keys = turn • Edit the <code>map</code> array in the script to change the world</div>
    <div class="credits">Favicon mirrors the view (tiny 16×16)</div>
  </div>

<script>
/* ===========================
   CONFIG / MAP (edit this)
   0 = air, 1 = stone, 2 = dirt, 3 = grass
   Keep rectangular rows of equal length.
   =========================== */
const map = [
  [1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,0,1],
  [1,0,2,2,2,0,0,0,0,1],
  [1,0,2,3,2,0,0,3,0,1],
  [1,0,2,2,2,0,0,0,0,1],
  [1,0,0,0,0,0,0,0,0,1],
  [1,0,0,3,3,0,0,0,0,1],
  [1,0,0,0,0,0,2,2,0,1],
  [1,0,0,0,0,0,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,1],
];
const MAP_W = map[0].length, MAP_H = map.length;
const BLOCK_SIZE = 1.0; // world block unit

/* ===========================
   Player & controls
   =========================== */
let px = 4.5, py = 4.5, pz = 0.6; // x,z position on grid (py used as z in earlier code; here use px, py)
let yaw = 0; // rotation (radians)
const keys = {};
window.addEventListener('keydown', e=> keys[e.key]=true);
window.addEventListener('keyup', e=> keys[e.key]=false);

/* ===========================
   Canvas + favicon
   =========================== */
const view = document.getElementById('view');
const ctx = view.getContext('2d');

const favCanvas = document.createElement('canvas');
favCanvas.width = 16; favCanvas.height = 16;
const fctx = favCanvas.getContext('2d');

/* ===========================
   Colors / materials
   =========================== */
function colorFor(id){
  if (id===1) return '#8d8d8d'; // stone
  if (id===2) return '#9b6a3c'; // dirt
  if (id===3) return '#4db63b'; // grass
  return '#000';
}
function shadeHex(hex, factor){
  const r = parseInt(hex.slice(1,3),16);
  const g = parseInt(hex.slice(3,5),16);
  const b = parseInt(hex.slice(5,7),16);
  const nr = Math.max(0,Math.min(255,Math.round(r*factor)));
  const ng = Math.max(0,Math.min(255,Math.round(g*factor)));
  const nb = Math.max(0,Math.min(255,Math.round(b*factor)));
  return '#' + [nr,ng,nb].map(n=>n.toString(16).padStart(2,'0')).join('');
}

/* ===========================
   Projection & camera helpers
   =========================== */
const W = view.width, H = view.height;
const fov = Math.PI/3; // 60 deg
const focal = (W/2) / Math.tan(fov/2);

function worldToCamera(pxw, pyw, pzw, camX, camY, camZ, yaw){
  // translate by camera
  const dx = pxw - camX;
  const dy = pyw - camY;
  const dz = pzw - camZ;
  // rotate Y (yaw)
  const cos = Math.cos(-yaw);
  const sin = Math.sin(-yaw);
  const rx = dx * cos - dz * sin;
  const rz = dx * sin + dz * cos;
  return {x: rx, y: dy, z: rz}; // camera-space
}
function project(cam){
  // perspective projection to 2D screen coords
  // cam: {x,y,z} in camera space (z forward)
  const z = Math.max(0.001, cam.z);
  const sx = (cam.x * (focal / z)) + W/2;
  const sy = (-cam.y * (focal / z)) + H/2;
  return {x: sx, y: sy, z: z};
}

/* ===========================
   Build faces to draw
   ===========================
   For each block we create polygons for the 6 faces
   with their normals and average depth for painter's sort.
   =========================== */
function blockFaces(x, y, id){
  // x,z grid to world coordinates: block spans [x,x+1] in x, y is height index (we'll keep single-layer ground at y=0..1)
  // We'll place blocks at world coordinates (bx, by, bz) with by from 0..1 (single-layer)
  const bx = x;
  const bz = y;
  const faces = [];
  // cube corners (y=0..1)
  const c = [
    [bx, 0, bz],
    [bx+1, 0, bz],
    [bx+1, 1, bz],
    [bx, 1, bz],
    [bx, 0, bz+1],
    [bx+1,0, bz+1],
    [bx+1,1, bz+1],
    [bx,1, bz+1]
  ];
  // faces: each face as list of corner indices + normal
  const faceDefs = [
    {idx:[0,1,2,3], normal:[0, -1, 0]}, // bottom (rarely visible)
    {idx:[4,5,6,7], normal:[0, 1, 0]}, // top
    {idx:[0,4,7,3], normal:[-1, 0, 0]}, // left (-x)
    {idx:[1,5,6,2], normal:[1, 0, 0]}, // right (+x)
    {idx:[0,1,5,4], normal:[0, 0, -1]}, // back (-z)
    {idx:[3,2,6,7], normal:[0, 0, 1]} // front (+z)
  ];
  for (let f of faceDefs){
    faces.push({
      verts: f.idx.map(i=>({x:c[i][0], y:c[i][1], z:c[i][2]})),
      normal: f.normal,
      id: id
    });
  }
  return faces;
}

/* ===========================
   Visibility culling helpers
   =========================== */
function neighborSolid(ix, iz){
  if (ix<0 || iz<0 || ix>=MAP_W || iz>=MAP_H) return true;
  return map[iz][ix] !== 0;
}

/* ===========================
   Create list of visible faces each frame
   =========================== */
function gatherFaces(){
  const camX = px, camY = pz, camZ = py; // note: using px,py for horizontal coords, pz for height
  const faces = [];
  for (let z=0; z<MAP_H; z++){
    for (let x=0; x<MAP_W; x++){
      const id = map[z][x];
      if (id === 0) continue;
      // only include faces that are adjacent to air (or outside)
      // top: always keep (makes blocks visible)
      // left if neighbor at x-1 is air
      const farr = blockFaces(x,z,id);
      // bottom skip to save
      // check adjacency to decide which faces to push
      // map coords: map[row=z][col=x]
      const leftSolid = neighborSolid(x-1,z);
      const rightSolid = neighborSolid(x+1,z);
      const backSolid = neighborSolid(x,z-1);
      const frontSolid = neighborSolid(x,z+1);

      // index mapping in faceDefs:
      // 0 bottom,1 top,2 left,3 right,4 back,5 front
      if (!leftSolid) faces.push(farr[2]);
      if (!rightSolid) faces.push(farr[3]);
      if (!backSolid) faces.push(farr[4]);
      if (!frontSolid) faces.push(farr[5]);
      faces.push(farr[1]); // top always
    }
  }
  return faces;
}

/* ===========================
   Render routine
   =========================== */
function render(){
  // clear
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,W,H);
  fctx.fillStyle = '#000';
  fctx.fillRect(0,0,16,16);

  // gather faces
  const faces = gatherFaces();
  const camX = px, camY = pz, camZ = py;

  // convert faces to camera space and project, compute depth
  const drawList = [];
  for (let f of faces){
    // compute face center for culling and depth
    const cx = f.verts.reduce((s,v)=>s+v.x,0)/4;
    const cy = f.verts.reduce((s,v)=>s+v.y,0)/4;
    const cz = f.verts.reduce((s,v)=>s+v.z,0)/4;
    // camera-space center
    const ccam = worldToCamera(cx, cy, cz, camX, camY, camZ, yaw);
    if (ccam.z <= 0.1) continue; // behind camera
    // face normal in world coords and simple backface cull: only draw faces roughly facing camera
    // compute camera vector from face center
    const camVec = {x: camX - cx, y: camY - cy, z: camZ - cz};
    // normal (we'll use given normal; since cube faces axis-aligned we can compute dot in world)
    const n = f.normal;
    const dot = n.x*camVec.x + n.y*camVec.y + n.z*camVec.z; // if positive, normal points away from camera; choose sign to draw facing camera
    // For axis aligned and our camVec, draw faces where dot < 0 (normal faces toward camera)
    if (dot >= 0) {
      // still might be visible due to orientation; keep top always
      if (!(n[1] === 1)) continue;
    }

    // project corners
    const proj = f.verts.map(v=>{
      const cam = worldToCamera(v.x, v.y, v.z, camX, camY, camZ, yaw);
      if (cam.z <= 0.001) return null;
      const p = project(cam);
      return p;
    });
    if (proj.some(p=>p===null)) continue;

    // average depth (smaller z means closer? we use z)
    const depth = proj.reduce((s,p)=>s+p.z,0)/proj.length;
    drawList.push({proj, depth, id: f.id, normal: f.normal});
  }

  // painter's: sort by far->near
  drawList.sort((a,b)=>b.depth - a.depth);

  // light direction (simple)
  const light = {x: 0.5, y: 0.8, z: -0.3};
  const llen = Math.hypot(light.x,light.y,light.z);
  light.x/=llen; light.y/=llen; light.z/=llen;

  // draw polygons
  for (let item of drawList){
    const p = item.proj;
    // shading based on face normal
    const normal = item.normal;
    // normal as vector
    const nx = normal[0], ny = normal[1], nz = normal[2];
    const ndot = clamp(nx*light.x + ny*light.y + nz*light.z, -1, 1);
    const shade = 0.5 + (ndot+1)/4; // range ~[0.25..1.0]
    const base = colorFor(item.id);
    const fill = shadeHex(base, shade);

    ctx.beginPath();
    ctx.moveTo(p[0].x, p[0].y);
    for (let i=1;i<p.length;i++) ctx.lineTo(p[i].x, p[i].y);
    ctx.closePath();
    ctx.fillStyle = fill;
    ctx.fill();
    // outline
    ctx.strokeStyle = shadeHex('#000000', 0.8);
    ctx.lineWidth = 0.6;
    ctx.stroke();

    // also draw scaled down to favicon (quick approximate)
    fctx.beginPath();
    fctx.moveTo(p[0].x * (16/W), p[0].y * (16/H));
    for (let i=1;i<p.length;i++) fctx.lineTo(p[i].x * (16/W), p[i].y * (16/H));
    fctx.closePath();
    fctx.fillStyle = fill;
    fctx.fill();
  }

  // HUD: center reticle on big canvas
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(W/2 - 6, H/2); ctx.lineTo(W/2 + 6, H/2);
  ctx.moveTo(W/2, H/2 - 6); ctx.lineTo(W/2, H/2 + 6);
  ctx.stroke();

  // set favicon from favCanvas
  document.getElementById('favicon').href = favCanvas.toDataURL('image/png');
}

/* ===========================
   Movement + collision
   =========================== */
function isSolid(x,z){
  const xi = Math.floor(x), zi = Math.floor(z);
  if (xi < 0 || zi < 0 || xi >= MAP_W || zi >= MAP_H) return true;
  return map[zi][xi] !== 0;
}

function movementLoop(){
  // rotation
  if (keys['ArrowLeft']) yaw -= 0.06;
  if (keys['ArrowRight']) yaw += 0.06;

  // movement local vector
  let mx=0, mz=0;
  const speed = 0.06;
  if (keys['w']) { mx += Math.cos(yaw) * speed; mz += Math.sin(yaw) * speed; }
  if (keys['s']) { mx -= Math.cos(yaw) * speed; mz -= Math.sin(yaw) * speed; }
  if (keys['a']) { mx += Math.sin(yaw) * speed; mz -= Math.cos(yaw) * speed; }
  if (keys['d']) { mx -= Math.sin(yaw) * speed; mz += Math.cos(yaw) * speed; }

  // attempt move with axis separation
  let nx = px + mx, nz = py;
  if (!isSolid(nx, nz)) px = nx;
  nx = px; nz = py + mz;
  if (!isSolid(nx, nz)) py = nz;

  requestAnimationFrame(movementLoop);
}

/* ===========================
   Spawn safety: ensure player starts in air above solid
   =========================== */
function findSpawn(){
  for (let z=0; z<MAP_H; z++){
    for (let x=0; x<MAP_W; x++){
      // find topmost solid in column and spawn above it in nearby air
      if (map[z][x] !== 0){
        // check above coords for free 1x1 area
        const sx = x + 0.5, sz = z + 0.5;
        // spawn at first adjacent air cell if available
        const checks = [
          [sx+1, sz], [sx-1, sz], [sx, sz+1], [sx, sz-1], [sx+1, sz+1], [sx-1, sz-1]
        ];
        for (let [cx,cz] of checks){
          const xi = Math.floor(cx), zi = Math.floor(cz);
          if (xi >=0 && zi >=0 && xi<MAP_W && zi<MAP_H && map[zi][xi] === 0){
            return {x: cx, z: cz};
          }
        }
      }
    }
  }
  return {x:1.5, z:1.5};
}
const spawn = findSpawn();
px = spawn.x; py = spawn.z;

/* ===========================
   Main loop
   =========================== */
function frame(){
  render();
  requestAnimationFrame(frame);
}
movementLoop();
frame();

/* ===========================
   Utility
   =========================== */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

</script>
</body>
</html>
