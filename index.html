<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Canvas Voxel — Loading...</title>
<link id="favicon" rel="icon" href="">
<style>
  :root{--bg:#071018;--muted:#9fb7c9}
  html,body{height:100%;margin:0;background:var(--bg);color:#e6f3fb;font-family:Inter,Arial,Helvetica,sans-serif}
  .wrap{display:flex;flex-direction:column;align-items:center;padding:18px}
  h1{margin:6px 0 12px 0;font-weight:600}
  #view{width:540px;height:540px;border:4px solid #0f2130; image-rendering: pixelated; background:#000}
  .hint{color:var(--muted);margin-top:8px;font-size:13px}
  .small{font-size:12px;color:#7f9cae}
</style>
</head>
<body>
  <div class="wrap">
    <h1>MiniCraft (Canvas Voxels)</h1>
    <canvas id="view" width="270" height="270"></canvas>
    <div class="hint">WASD = move • ArrowLeft/Right = turn • Left click = mine • I = toggle inventory in title • H = toggle health in title</div>
    <div class="small">Map: 64×64×64 • Render radius adjustable in code</div>
  </div>

<script>
/* ===========================
   CONFIG
   =========================== */
const WORLD_SIZE = 64; // 64^3 world
const WORLD_H = 64;
const RENDER_RADIUS = 18; // blocks
const BLOCK_AIR = 0, BLOCK_STONE = 1, BLOCK_DIRT = 2, BLOCK_GRASS = 3, BLOCK_LOG = 4, BLOCK_LEAF = 5;
const REACH = 5.0; // mining reach
const MAX_HEIGHT = WORLD_H - 1;

/* ===========================
   Flat typed storage for blocks
   index(x,y,z) -> idx
   =========================== */
const W = WORLD_SIZE, H = WORLD_H, D = WORLD_SIZE;
const SIZE = W * H * D;
const blocks = new Uint8Array(SIZE);

function idx(x,y,z){
  return ( (y * D) + z) * W + x;
}
function getBlock(x,y,z){
  if (x < 0 || z < 0 || x >= W || z >= D || y < 0 || y >= H) return BLOCK_AIR;
  return blocks[idx(x,y,z)];
}
function setBlock(x,y,z,id){
  if (x < 0 || z < 0 || x >= W || z >= D || y < 0 || y >= H) return;
  blocks[idx(x,y,z)] = id;
}

/* ===========================
   Simple noise functions (value noise)
   Small, fast, OK for terrain/caves
   =========================== */
function pseudoHash(i){
  i = (i<<13) ^ i;
  return (1.0 - ((i * (i * i * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);
}
function smoothNoise2(x,y){
  const xi = Math.floor(x), yi = Math.floor(y);
  const xf = x - xi, yf = y - yi;
  const v00 = pseudoHash(xi + yi*57);
  const v10 = pseudoHash(xi+1 + yi*57);
  const v01 = pseudoHash(xi + (yi+1)*57);
  const v11 = pseudoHash(xi+1 + (yi+1)*57);
  // bilinear interpolation with ease
  const u = xf*xf*(3-2*xf);
  const v = yf*yf*(3-2*yf);
  const a = v00*(1-u) + v10*u;
  const b = v01*(1-u) + v11*u;
  return a*(1-v) + b*v;
}
function fractalNoise2(x,y,octaves=4,scale=1){
  let amp = 1, freq = 1, sum = 0, norm = 0;
  for (let i=0;i<octaves;i++){
    sum += smoothNoise2(x*freq/scale, y*freq/scale) * amp;
    norm += amp;
    amp *= 0.5; freq *= 2;
  }
  return sum / norm; // roughly [-1..1]
}
// 3D noise by combining 2D slices (cheap)
function fractalNoise3(x,y,z,octaves=3,scale=1){
  // combine XY, YZ, XZ slices
  return (fractalNoise2(x,y,octaves,scale) + fractalNoise2(y,z,octaves,scale) + fractalNoise2(x,z,octaves,scale)) / 3;
}

/* ===========================
   Generate terrain (heightmap), trees, caves
   Place blocks into blocks[] array
   =========================== */
function generateWorld(){
  // clear
  for (let i=0;i<SIZE;i++) blocks[i] = BLOCK_AIR;

  // height map (0..H-1)
  for (let z=0; z<D; z++){
    for (let x=0; x<W; x++){
      // normalized coords
      const nx = x / W, nz = z / D;
      // combine noises to get interesting terrain
      let hNoise = fractalNoise2(x*0.8, z*0.8, 5, 24) * 8
                 + fractalNoise2(x*0.04, z*0.04, 3, 1) * 10
                 + fractalNoise2(x*0.2, z*0.2, 4, 8) * 4;
      // bias to middle
      const centerBias = (1 - Math.hypot(nx-0.5,nz-0.5)/0.7071) * 4;
      hNoise += centerBias;
      let height = Math.floor( (H/4) + hNoise );
      height = Math.max(2, Math.min(H-4, height));

      // fill from 0..height
      for (let y=0; y<=height; y++){
        if (y < height - 3) setBlock(x,y,z, BLOCK_STONE);
        else if (y < height - 1) setBlock(x,y,z, BLOCK_DIRT);
        else setBlock(x,y,z, BLOCK_GRASS);
      }
    }
  }

  // caves: carve by 3D noise threshold
  for (let z=2; z<D-2; z++){
    for (let x=2; x<W-2; x++){
      for (let y=2; y<H-6; y++){
        // deeper = more caves
        const n = fractalNoise3(x*0.12, y*0.12, z*0.12, 3, 12);
        // threshold that depends on y (more caves lower)
        const threshold = 0.2 + (y / H) * 0.4;
        if (n > threshold) {
          // carve
          setBlock(x,y,z, BLOCK_AIR);
        }
      }
    }
  }

  // trees: randomly on grass and with free space
  for (let z=2; z<D-2; z++){
    for (let x=2; x<W-2; x++){
      if (Math.random() < 0.008) {
        // find column top
        for (let y=H-1; y>=0; y--){
          if (getBlock(x,y,z) === BLOCK_GRASS){
            // check space for trunk and leaves
            const trunkH = 3 + Math.floor(Math.random()*2);
            let ok = true;
            for (let yy=y+1; yy<=y+trunkH+2; yy++){
              for (let lx=-2; lx<=2; lx++){
                for (let lz=-2; lz<=2; lz++){
                  if (getBlock(x+lx, yy, z+lz) !== BLOCK_AIR) ok = false;
                }
              }
            }
            if (!ok) break;
            // place trunk
            for (let t=1; t<=trunkH; t++) setBlock(x, y+t, z, BLOCK_LOG);
            // leaves cube
            for (let lx=-2; lx<=2; lx++){
              for (let lz=-2; lz<=2; lz++){
                for (let ly=trunkH-1; ly<=trunkH+1; ly++){
                  const ax = x+lx, ay = y+ly+1, az = z+lz;
                  if (Math.abs(lx) + Math.abs(lz) + Math.abs(ly) <= 4 && getBlock(ax,ay,az) === BLOCK_AIR) {
                    setBlock(ax,ay,az, BLOCK_LEAF);
                  }
                }
              }
            }
            break;
          }
        }
      }
    }
  }
}

generateWorld();

/* ===========================
   Player spawn: find safe spot (air above solid)
   =========================== */
function findSafeSpawn(){
  for (let z=2; z<D-2; z++){
    for (let x=2; x<W-2; x++){
      for (let y=H-6; y>2; y--){
        const below = getBlock(x, y-1, z);
        const here  = getBlock(x, y, z);
        const above = getBlock(x, y+1, z);
        if (below !== BLOCK_AIR && here === BLOCK_AIR && above === BLOCK_AIR) {
          return {x: x+0.5, y: y+0.6, z: z+0.5};
        }
      }
    }
  }
  return {x: 4.5, y: 10.6, z: 4.5};
}
const spawn = findSafeSpawn();
let playerX = spawn.x, playerY = spawn.y, playerZ = spawn.z;

/* ===========================
   Inventory & health
   =========================== */
const inventory = {};
let health = 20;
let showInventoryInTitle = false;
let showHealthInTitle = false;

function addToInventory(blockId){
  if (!inventory[blockId]) inventory[blockId] = 0;
  inventory[blockId]++;
  updateTitle();
}
function blockName(id){
  if (id === BLOCK_STONE) return "stone";
  if (id === BLOCK_DIRT) return "dirt";
  if (id === BLOCK_GRASS) return "grass";
  if (id === BLOCK_LOG) return "log";
  if (id === BLOCK_LEAF) return "leaf";
  return "air";
}
function updateTitle(){
  let parts = [];
  if (showInventoryInTitle){
    const invParts = [];
    for (let id in inventory){
      invParts.push(`${blockName(Number(id))} x${inventory[id]}`);
    }
    parts.push("Inv: " + (invParts.length ? invParts.join(", ") : "empty"));
  }
  if (showHealthInTitle) parts.push(`Health: ${health}`);
  document.title = parts.length ? parts.join(" | ") : "MiniCraft (Canvas Voxels)";
}

/* ===========================
   Canvas / rendering helpers
   =========================== */
const canvas = document.getElementById('view');
const ctx = canvas.getContext('2d');
const fav = document.createElement('canvas');
fav.width = 16; fav.height = 16;
const fctx = fav.getContext('2d');

const VIEW_W = canvas.width, VIEW_H = canvas.height;
const FOV = Math.PI/3;
const FOCAL = (VIEW_W/2) / Math.tan(FOV/2);

// camera yaw controls
const keys = {};
window.addEventListener('keydown', (e)=> {
  keys[e.key] = true;
  // toggles
  if (e.key === 'i' || e.key === 'I') { showInventoryInTitle = !showInventoryInTitle; updateTitle(); }
  if (e.key === 'h' || e.key === 'H') { showHealthInTitle = !showHealthInTitle; updateTitle(); }
});
window.addEventListener('keyup', (e)=> keys[e.key] = false);

// mouse for mining
let mouseDown = false;
window.addEventListener('mousedown', e=> { if (e.button === 0) mouseDown = true; });
window.addEventListener('mouseup', e=> { if (e.button === 0) mouseDown = false; });

// helper: world->camera space and project
function worldToCam(pxw, pyw, pzw, camX, camY, camZ, yaw){
  const dx = pxw - camX; const dy = pyw - camY; const dz = pzw - camZ;
  const cos = Math.cos(-yaw), sin = Math.sin(-yaw);
  const rx = dx * cos - dz * sin;
  const rz = dx * sin + dz * cos;
  return {x: rx, y: dy, z: rz};
}
function projectPoint(cam){ // cam: {x,y,z}
  const z = Math.max(0.001, cam.z);
  const sx = (cam.x * (FOCAL / z)) + VIEW_W/2;
  const sy = (-cam.y * (FOCAL / z)) + VIEW_H/2;
  return {x: sx, y: sy, z: z};
}

/* ===========================
   Collect visible faces within render radius and draw them
   Face culling and painter's sorting
   =========================== */
function gatherAndRender(){
  // clear screens
  ctx.fillStyle = "#000"; ctx.fillRect(0,0,VIEW_W, VIEW_H);
  fctx.fillStyle = "#000"; fctx.fillRect(0,0,16,16);

  const camX = playerX, camY = playerY, camZ = playerZ;
  const faces = [];

  const minX = Math.max(0, Math.floor(camX) - RENDER_RADIUS);
  const maxX = Math.min(W-1, Math.floor(camX) + RENDER_RADIUS);
  const minZ = Math.max(0, Math.floor(camZ) - RENDER_RADIUS);
  const maxZ = Math.min(D-1, Math.floor(camZ) + RENDER_RADIUS);
  const minY = Math.max(0, Math.floor(camY) - RENDER_RADIUS);
  const maxY = Math.min(H-1, Math.floor(camY) + RENDER_RADIUS);

  // iterate nearby voxels
  for (let z=minZ; z<=maxZ; z++){
    for (let x=minX; x<=maxX; x++){
      for (let y=minY; y<=maxY; y++){
        const id = getBlock(x,y,z);
        if (id === BLOCK_AIR) continue;
        // for each of 6 faces check neighbor; if neighbor is air then face visible
        // face represented by 4 points in world coords
        // define corners
        const px0 = x, px1 = x+1;
        const py0 = y, py1 = y+1;
        const pz0 = z, pz1 = z+1;
        // faces with normals and verts (in ccw)
        const faceDefs = [
          {normal:[0,-1,0], verts:[[px0,py0,pz0],[px1,py0,pz0],[px1,py0,pz1],[px0,py0,pz1]]}, // bottom
          {normal:[0,1,0], verts:[[px0,py1,pz0],[px1,py1,pz0],[px1,py1,pz1],[px0,py1,pz1]]}, // top
          {normal:[-1,0,0], verts:[[px0,py0,pz1],[px0,py1,pz1],[px0,py1,pz0],[px0,py0,pz0]]}, // left (-x)
          {normal:[1,0,0], verts:[[px1,py0,pz0],[px1,py1,pz0],[px1,py1,pz1],[px1,py0,pz1]]}, // right (+x)
          {normal:[0,0,-1], verts:[[px1,py0,pz0],[px0,py0,pz0],[px0,py1,pz0],[px1,py1,pz0]]}, // back (-z)
          {normal:[0,0,1], verts:[[px0,py0,pz1],[px1,py0,pz1],[px1,py1,pz1],[px0,py1,pz1]]}  // front (+z)
        ];

        for (let f of faceDefs){
          // neighbor check
          const nx = x + f.normal[0], ny = y + f.normal[1], nz = z + f.normal[2];
          if (getBlock(nx,ny,nz) !== BLOCK_AIR) continue; // occluded

          // camera-space culling: compute center and skip if behind cam
          const cx = (f.verts[0][0]+f.verts[1][0]+f.verts[2][0]+f.verts[3][0]) / 4;
          const cy = (f.verts[0][1]+f.verts[1][1]+f.verts[2][1]+f.verts[3][1]) / 4;
          const cz = (f.verts[0][2]+f.verts[1][2]+f.verts[2][2]+f.verts[3][2]) / 4;
          const camSpace = worldToCam(cx, cy, cz, camX, camY, camZ, playerYaw);
          if (camSpace.z <= 0) continue;

          // project verts
          const proj = [];
          let skip = false;
          for (let v of f.verts){
            const cs = worldToCam(v[0], v[1], v[2], camX, camY, camZ, playerYaw);
            if (cs.z <= 0.001) { skip = true; break; }
            const p = projectPoint(cs);
            proj.push(p);
          }
          if (skip) continue;

          // average depth
          const depth = proj.reduce((s,p)=>s+p.z,0) / proj.length;
          faces.push({proj, depth, id, normal: f.normal});
        }
      }
    }
  }

  // painter's sort (far to near)
  faces.sort((a,b)=> b.depth - a.depth);

  // lighting vector
  const light = normalize([0.5, 0.9, -0.3]);

  // draw faces
  for (let f of faces){
    const base = blockColor(f.id);
    const nd = Math.max(0, dot(normalize(f.normal), light));
    const shade = 0.5 + nd*0.5;
    const fill = shadeHex(base, shade);
    // polygon
    ctx.beginPath();
    ctx.moveTo(f.proj[0].x, f.proj[0].y);
    for (let i=1;i<f.proj.length;i++) ctx.lineTo(f.proj[i].x, f.proj[i].y);
    ctx.closePath();
    ctx.fillStyle = fill; ctx.fill();
    ctx.strokeStyle = "#000"; ctx.lineWidth = 0.6; ctx.stroke();

    // draw to favicon roughly (scale)
    fctx.beginPath();
    fctx.moveTo(f.proj[0].x * (16/VIEW_W), f.proj[0].y * (16/VIEW_H));
    for (let i=1;i<f.proj.length;i++) fctx.lineTo(f.proj[i].x * (16/VIEW_W), f.proj[i].y * (16/VIEW_H));
    fctx.closePath();
    fctx.fillStyle = fill; fctx.fill();
  }

  // draw center reticle
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.beginPath();
  ctx.moveTo(VIEW_W/2 - 6, VIEW_H/2); ctx.lineTo(VIEW_W/2 + 6, VIEW_H/2);
  ctx.moveTo(VIEW_W/2, VIEW_H/2 - 6); ctx.lineTo(VIEW_W/2, VIEW_H/2 + 6);
  ctx.stroke();

  // set favicon
  document.getElementById('favicon').href = fav.toDataURL('image/png');
}

/* ===========================
   color helpers for blocks
   =========================== */
function blockColor(id){
  if (id === BLOCK_STONE) return '#8d8d8d';
  if (id === BLOCK_DIRT) return '#9b6a3c';
  if (id === BLOCK_GRASS) return '#4db63b';
  if (id === BLOCK_LOG) return '#6b3f24';
  if (id === BLOCK_LEAF) return '#2fa04a';
  return '#000';
}
function shadeHex(hex, factor){
  const r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
  const nr = Math.round(Math.max(0,Math.min(255, r*factor)));
  const ng = Math.round(Math.max(0,Math.min(255, g*factor)));
  const nb = Math.round(Math.max(0,Math.min(255, b*factor)));
  return '#'+[nr,ng,nb].map(n=>n.toString(16).padStart(2,'0')).join('');
}
function dot(a,b){ return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }
function normalize(a){ const l = Math.hypot(a[0],a[1],a[2])||1; return [a[0]/l,a[1]/l,a[2]/l]; }

/* ===========================
   Controls / movement / collision
   =========================== */
let playerYaw = 0;
function movementStep(){
  const moveSpeed = 0.09;
  const rotSpeed = 0.06;
  // rotation
  if (keys['ArrowLeft']) playerYaw -= rotSpeed;
  if (keys['ArrowRight']) playerYaw += rotSpeed;
  // movement (W forward)
  let mx = 0, mz = 0;
  if (keys['w'] || keys['W']) { mx += Math.cos(playerYaw) * moveSpeed; mz += Math.sin(playerYaw) * moveSpeed; }
  if (keys['s'] || keys['S']) { mx -= Math.cos(playerYaw) * moveSpeed; mz -= Math.sin(playerYaw) * moveSpeed; }
  if (keys['a'] || keys['A']) { mx += Math.sin(playerYaw) * moveSpeed; mz -= Math.cos(playerYaw) * moveSpeed; }
  if (keys['d'] || keys['D']) { mx -= Math.sin(playerYaw) * moveSpeed; mz += Math.cos(playerYaw) * moveSpeed; }
  // apply axis-separated collision
  let nx = playerX + mx, nz = playerZ;
  if (!solidAt(nx, playerY, nz)) playerX = nx;
  nx = playerX; nz = playerZ + mz;
  if (!solidAt(nx, playerY, nz)) playerZ = nz;
}
function solidAt(xf, yf, zf){
  // treat player as small box; check feet cell and head
  const footY = Math.floor(yf - 0.3);
  const headY = Math.floor(yf + 0.3);
  const xi = Math.floor(xf), zi = Math.floor(zf);
  if (getBlock(xi, footY, zi) !== BLOCK_AIR) return true;
  if (getBlock(xi, headY, zi) !== BLOCK_AIR) return true;
  return false;
}

/* ===========================
   Mining: cast a ray from camera center into world to find target voxel
   =========================== */
function castCenterRay(maxDist=REACH, step=0.2){
  // cast from camera position along yaw
  const ox = playerX, oy = playerY, oz = playerZ;
  const dx = Math.cos(playerYaw), dz = Math.sin(playerYaw);
  let dist = 0;
  while (dist <= maxDist){
    const rx = ox + dx*dist, ry = oy, rz = oz + dz*dist;
    const bx = Math.floor(rx), by = Math.floor(ry), bz = Math.floor(rz);
    if (getBlock(bx,by,bz) !== BLOCK_AIR) return {x:bx,y:by,z:bz,dist};
    dist += step;
  }
  return null;
}
function mineCenterBlock(){
  const hit = castCenterRay();
  if (!hit) return;
  const id = getBlock(hit.x, hit.y, hit.z);
  if (id === BLOCK_AIR) return;
  // break instantly
  setBlock(hit.x, hit.y, hit.z, BLOCK_AIR);
  addToInventory(id);
}

/* ===========================
   Mouse click handler — mine
   =========================== */
window.addEventListener('mousedown', (e)=>{
  if (e.button === 0) {
    mineCenterBlock();
  }
});

/* ===========================
   Main loops
   =========================== */
function mainTick(){
  movementStep();
  gatherAndRender();
  // small HUD draw: health & inventory counts on canvas corner
  ctx.fillStyle = 'rgba(0,0,0,0.4)';
  ctx.fillRect(6,6,140,34);
  ctx.fillStyle = '#fff'; ctx.font = '10px monospace';
  ctx.fillText(`Health: ${health}`, 12, 18);
  // inventory short
  const invParts = [];
  for (let id in inventory) invParts.push(`${blockName(Number(id))}:${inventory[id]}`);
  ctx.fillText(`Inv: ${invParts.slice(0,4).join(' ')}`, 12, 32);

  // also update favicon (already done in gatherAndRender)
  requestAnimationFrame(mainTick);
}
mainTick();

/* ===========================
   Title initial
   =========================== */
updateTitle();

</script>
</body>
</html>
