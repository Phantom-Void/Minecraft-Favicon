<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Voxel — Fixed Camera (Fast)</title>
<link id="favicon" rel="icon" href="">
<style>
  :root{--bg:#071018;--muted:#9fb7c9}
  html,body{height:100%;margin:0;background:var(--bg);color:#e6f3fb;font-family:Inter,Arial,Helvetica,sans-serif}
  .wrap{display:flex;flex-direction:column;align-items:center;padding:12px}
  h1{margin:6px 0 10px 0}
  canvas#view{width:640px;height:426px;border:4px solid #0f2130;
    image-rendering: pixelated;
    background:#000;
    display:block
  }
  .hint{color:var(--muted);margin-top:8px;font-size:13px;text-align:center}
</style>
</head>

<body>
<div class="wrap">
  <h1>Voxel — Fixed Camera (Fast)</h1>
  <canvas id="view" width="240" height="160"></canvas>
  <div class="hint">WASD move • Mouse look (click canvas) • Space jump • LMB mine • I = inv • H = health</div>
</div>

<script>
/* FULL GAME LOGIC (unchanged except camera) */
/* — trimmed for readability — you already have all this */

const W = 64, D = 64, H = 64;
const CANVAS_W = 240, CANVAS_H = 160;
const FOV = Math.PI/3;
const REACH = 6;
const FAV = 16;
const MAX_RENDER_DIST = 48;

/* ... ALL YOUR ORIGINAL CODE ... */
/* ... blocks, noise, worldgen, movement, physics, rendering ... */
/* ... DDA raycast, collision, mining ... */

/* ------------ CAMERA FIX --------------- */
/* ★ NEW cameraRayDir (no more flipping, no stretching) */
function cameraRayDir(pixelX, pixelY, canvasW = CANVAS_W, canvasH = CANVAS_H) {
  // NDC (normalized device coords)
  const nx = (pixelX - canvasW / 2) / (canvasW / 2);
  const ny = (canvasH / 2 - pixelY) / (canvasH / 2);

  // Fix vertical stretching (correct aspect)
  const aspect = canvasW / canvasH;
  const sx = Math.tan(FOV / 2) * nx * aspect;
  const sy = Math.tan(FOV / 2) * ny;

  // Forward direction from yaw/pitch
  const forward = {
    x: Math.cos(pitch) * Math.cos(yaw),
    y: Math.sin(pitch),
    z: Math.cos(pitch) * Math.sin(yaw),
  };

  const worldUp = { x: 0, y: 1, z: 0 };

  // Compute right = worldUp × forward
  let right = cross(worldUp, forward);
  let rLen = Math.hypot(right.x, right.y, right.z);

  // ★ IMPORTANT:
  // If camera is looking straight up/down, right becomes nearly zero → flip.
  // Fix: fallback to a horizontal right vector from yaw.
  if (rLen < 1e-5) {
    right = { x: -Math.cos(yaw), y: 0, z: Math.sin(yaw) };
    rLen = Math.hypot(right.x, right.y, right.z) || 1;
  }

  // Normalize right
  right.x /= rLen;
  right.y /= rLen;
  right.z /= rLen;

  // Compute stable up vector
  let up = cross(right, forward);
  const uLen = Math.hypot(up.x, up.y, up.z) || 1;
  up.x /= uLen; up.y /= uLen; up.z /= uLen;

  // Build final ray direction
  let dir = {
    x: forward.x + right.x * sx + up.x * sy,
    y: forward.y + right.y * sx + up.y * sy,
    z: forward.z + right.z * sx + up.z * sy
  };

  const L = Math.hypot(dir.x, dir.y, dir.z) || 1;
  dir.x /= L; dir.y /= L; dir.z /= L;
  return dir;
}
/* ------------ END CAMERA FIX ------------- */

/* ... REST OF YOUR ORIGINAL FILE (renderFrame, mining, loop, etc) ... */

</script>
</body>
</html>
